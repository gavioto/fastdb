<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FastDB: database.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>database.h</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//-&lt; DATABASE.H &gt;----------------------------------------------------*--------*</span>
<a name="l00002"></a>00002 <span class="comment">// FastDB                    Version 1.0         (c) 1999  GARRET    *     ?  *</span>
<a name="l00003"></a>00003 <span class="comment">// (Main Memory Database Management System)                          *   /\|  *</span>
<a name="l00004"></a>00004 <span class="comment">//                                                                   *  /  \  *</span>
<a name="l00005"></a>00005 <span class="comment">//                          Created:     20-Nov-98    K.A. Knizhnik  * / [] \ *</span>
<a name="l00006"></a>00006 <span class="comment">//                          Last update: 23-Dec-98    K.A. Knizhnik  * GARRET *</span>
<a name="l00007"></a>00007 <span class="comment">//-------------------------------------------------------------------*--------*</span>
<a name="l00008"></a>00008 <span class="comment">// Database management</span>
<a name="l00009"></a>00009 <span class="comment">//-------------------------------------------------------------------*--------*</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#ifndef __DATABASE_H__</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#define __DATABASE_H__</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;class.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;reference.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;file.h&quot;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 BEGIN_FASTDB_NAMESPACE
<a name="l00019"></a>00019 
<a name="l00023"></a>00023 <span class="preprocessor">#ifdef DISKLESS_CONFIGURATION</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="comment">// In diskless confiuration database can not be reallocated</span>
<a name="l00025"></a>00025 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDefaultInitDatabaseSize = 32*1024*1024;
<a name="l00026"></a>00026 <span class="preprocessor">#else</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDefaultInitDatabaseSize = 1024*1024;
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDefaultInitIndexSize = 512*1024;
<a name="l00034"></a>00034 
<a name="l00038"></a>00038 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDefaultExtensionQuantum = 4*1024*1024;
<a name="l00039"></a>00039 
<a name="l00043"></a>00043 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> dbMaxParallelSearchThreads = 64;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">const</span> <span class="keywordtype">int</span> dbDefaultParallelScanThreshold = 1000;
<a name="l00046"></a>00046 <span class="keyword">const</span> <span class="keywordtype">int</span> dbDefaultPollInterval = 100*1000; <span class="comment">// milliseconds</span>
<a name="l00047"></a>00047 <span class="keyword">const</span> <span class="keywordtype">int</span> dbOpenPollInterval = 1000; <span class="comment">// milliseconds</span>
<a name="l00048"></a>00048 <span class="keyword">const</span> <span class="keywordtype">int</span> dbWaitReadyTimeout = 60*1000; <span class="comment">// milliseconds</span>
<a name="l00049"></a>00049 <span class="keyword">const</span> <span class="keywordtype">int</span> dbWaitStatusTimeout = 60*1000; <span class="comment">// milliseconds </span>
<a name="l00050"></a>00050 <span class="keyword">const</span> <span class="keywordtype">int</span> dbRecoveryConnectionAttempts = 3; 
<a name="l00051"></a>00051 <span class="keyword">const</span> <span class="keywordtype">int</span> dbStartupConnectionAttempts = 60;
<a name="l00052"></a>00052 <span class="keyword">const</span> <span class="keywordtype">int</span> dbReplicationWriteTimeout = 60*1000; <span class="comment">// milliseconds </span>
<a name="l00053"></a>00053 <span class="keyword">const</span> <span class="keywordtype">int</span> dbMaxAsyncRecoveryIterations = 10;   
<a name="l00054"></a>00054 <span class="keyword">const</span> <span class="keywordtype">int</span> dbTableHashSize = 1009;   
<a name="l00055"></a>00055 
<a name="l00059"></a>00059 <span class="keyword">enum</span> dbInternalObject { 
<a name="l00060"></a>00060     dbTableRow, 
<a name="l00061"></a>00061     dbPageObjectMarker,
<a name="l00062"></a>00062     dbTtreeMarker,
<a name="l00063"></a>00063     dbTtreeNodeMarker,
<a name="l00064"></a>00064     dbHashTableMarker,
<a name="l00065"></a>00065     dbHashTableItemMarker,
<a name="l00066"></a>00066     dbRtreeMarker,
<a name="l00067"></a>00067     dbRtreePageMarker,
<a name="l00068"></a>00068     
<a name="l00069"></a>00069     dbInternalObjectMarker = 7 <span class="comment">// mask for internals object markers</span>
<a name="l00070"></a>00070 };
<a name="l00071"></a>00071     
<a name="l00072"></a>00072 <span class="keyword">const</span> offs_t dbFreeHandleMarker = (offs_t)1 &lt;&lt; (<span class="keyword">sizeof</span>(offs_t)*8 - 1); 
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbAllocationQuantumBits = 4;
<a name="l00075"></a>00075 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbAllocationQuantum = 1 &lt;&lt; dbAllocationQuantumBits;
<a name="l00076"></a>00076 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbPageBits = 12;
<a name="l00077"></a>00077 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbPageSize = 1 &lt;&lt; dbPageBits;
<a name="l00078"></a>00078 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbIdsPerPage = dbPageSize / <span class="keyword">sizeof</span>(oid_t);
<a name="l00079"></a>00079 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbHandlesPerPage = dbPageSize / <span class="keyword">sizeof</span>(offs_t);
<a name="l00080"></a>00080 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbHandleBits = 1 + <span class="keyword">sizeof</span>(offs_t)/4; <span class="comment">// log(sizeof(offs_t))</span>
<a name="l00081"></a>00081 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbBitmapSegmentBits = dbPageBits + 3 + dbAllocationQuantumBits;
<a name="l00082"></a>00082 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbBitmapSegmentSize = 1 &lt;&lt; dbBitmapSegmentBits;
<a name="l00083"></a>00083 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbBitmapPages = 1 &lt;&lt; (dbDatabaseOffsetBits-dbBitmapSegmentBits);
<a name="l00084"></a>00084 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDirtyPageBitmapSize = 1 &lt;&lt; (dbDatabaseOidBits-dbPageBits+dbHandleBits-3);
<a name="l00085"></a>00085 <span class="keyword">const</span> <span class="keywordtype">size_t</span> dbDefaultSelectionLimit = 2000000000;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">const</span> <span class="keywordtype">int</span>    dbBMsearchThreshold = 512;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">const</span> <span class="keywordtype">char</span>   dbMatchAnyOneChar = <span class="charliteral">&#39;_&#39;</span>;
<a name="l00090"></a>00090 <span class="keyword">const</span> <span class="keywordtype">char</span>   dbMatchAnySubstring = <span class="charliteral">&#39;%&#39;</span>;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keyword">const</span> <span class="keywordtype">int</span>    dbMaxReaders = 64; <span class="comment">// maximal number of readers concurrently accessing the database</span>
<a name="l00093"></a>00093 
<a name="l00097"></a>00097 <span class="keyword">enum</span> dbPredefinedIds { 
<a name="l00098"></a>00098     dbInvalidId,
<a name="l00099"></a>00099     dbMetaTableId, 
<a name="l00100"></a>00100     dbBitmapId,
<a name="l00101"></a>00101     dbFirstUserId = dbBitmapId + dbBitmapPages
<a name="l00102"></a>00102 };
<a name="l00103"></a>00103 
<a name="l00107"></a><a class="code" href="classdbHeader.html">00107</a> <span class="keyword">class </span><a class="code" href="classdbHeader.html">dbHeader</a> { 
<a name="l00108"></a>00108   <span class="keyword">public</span>:
<a name="l00109"></a>00109     offs_t size;  <span class="comment">// database file size</span>
<a name="l00110"></a>00110     int4   curr;  <span class="comment">// current root</span>
<a name="l00111"></a>00111     int4   dirty; <span class="comment">// database was not closed normally</span>
<a name="l00112"></a>00112     int4   initialized; <span class="comment">// database is initilaized</span>
<a name="l00113"></a>00113 <span class="preprocessor">#if (dbDatabaseOffsetBits &gt; 32 &amp;&amp; defined(ALIGN_HEADER)) || defined(PAD_HEADER)</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>    int4   pad;
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>    <span class="keyword">struct </span>{ 
<a name="l00117"></a>00117         offs_t index;           <span class="comment">// offset to object index</span>
<a name="l00118"></a>00118         offs_t shadowIndex;     <span class="comment">// offset to shadow index</span>
<a name="l00119"></a>00119         oid_t  indexSize;       <span class="comment">// size of object index</span>
<a name="l00120"></a>00120         oid_t  shadowIndexSize; <span class="comment">// size of object index</span>
<a name="l00121"></a>00121         oid_t  indexUsed;       <span class="comment">// used part of the index   </span>
<a name="l00122"></a>00122         oid_t  freeList;        <span class="comment">// L1 list of free descriptors</span>
<a name="l00123"></a>00123     } root[2];
<a name="l00124"></a>00124     
<a name="l00125"></a>00125     int4 majorVersion;
<a name="l00126"></a>00126     int4 minorVersion;
<a name="l00127"></a>00127     int4 mode;
<a name="l00128"></a>00128     offs_t used;  
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="keyword">enum</span> { 
<a name="l00131"></a>00131         MODE_OID_64        = 0x01,
<a name="l00132"></a>00132         MODE_OFFS_64       = 0x02,
<a name="l00133"></a>00133         MODE_AUTOINCREMENT = 0x04,
<a name="l00134"></a>00134         MODE_RECTANGLE_DIM = 0x08
<a name="l00135"></a>00135     };    
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="keywordtype">int</span> getVersion() { 
<a name="l00138"></a>00138         <span class="keywordflow">return</span> majorVersion*100 + minorVersion;
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     
<a name="l00141"></a>00141     <span class="keywordtype">bool</span> isCompatible();
<a name="l00142"></a>00142     <span class="keyword">static</span> <span class="keywordtype">int</span> getCurrentMode();
<a name="l00143"></a>00143 };
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">union  </span>dbSynthesizedAttribute;
<a name="l00146"></a>00146 <span class="keyword">struct </span>dbInheritedAttribute;
<a name="l00147"></a>00147 <span class="keyword">class </span>dbDatabaseThreadContext;
<a name="l00148"></a>00148 <span class="keyword">class </span><a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>;
<a name="l00149"></a>00149 <span class="keyword">class </span><a class="code" href="classdbQuery.html">dbQuery</a>;
<a name="l00150"></a>00150 <span class="keyword">class </span>dbExprNode;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="keyword">struct </span>dbMemoryStatistic { 
<a name="l00153"></a>00153     offs_t used;
<a name="l00154"></a>00154     offs_t free;
<a name="l00155"></a>00155     offs_t nHoles;
<a name="l00156"></a>00156     offs_t minHoleSize;
<a name="l00157"></a>00157     offs_t maxHoleSize;
<a name="l00158"></a>00158     <span class="keywordtype">size_t</span> nHolesOfSize[dbDatabaseOffsetBits];
<a name="l00159"></a>00159 };
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">class </span>FixedSizeAllocator
<a name="l00162"></a>00162 {
<a name="l00163"></a>00163     <span class="keyword">struct </span>Hole { 
<a name="l00164"></a>00164         Hole*  next;
<a name="l00165"></a>00165         offs_t offs;
<a name="l00166"></a>00166     };
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="keywordtype">size_t</span> minSize;
<a name="l00169"></a>00169     <span class="keywordtype">size_t</span> maxSize;
<a name="l00170"></a>00170     <span class="keywordtype">size_t</span> quantum;
<a name="l00171"></a>00171     <span class="keywordtype">size_t</span> nChains;
<a name="l00172"></a>00172     <span class="keywordtype">size_t</span> bufSize;
<a name="l00173"></a>00173     Hole** chains;
<a name="l00174"></a>00174     Hole*  vacant;
<a name="l00175"></a>00175     Hole*  holes;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="keyword">public</span>:
<a name="l00178"></a>00178     <span class="keywordtype">size_t</span> hits;
<a name="l00179"></a>00179     <span class="keywordtype">size_t</span> faults;
<a name="l00180"></a>00180     <span class="keywordtype">size_t</span> retries;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     FixedSizeAllocator();
<a name="l00183"></a>00183     ~FixedSizeAllocator();
<a name="l00184"></a>00184        
<a name="l00185"></a>00185     <span class="keywordtype">void</span> init(<span class="keywordtype">size_t</span> minSize, <span class="keywordtype">size_t</span> maxSize, <span class="keywordtype">size_t</span> quantum, <span class="keywordtype">size_t</span> bufSize);
<a name="l00186"></a>00186     <span class="keywordtype">void</span> reset();
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     offs_t allocate(<span class="keywordtype">size_t</span> size) { 
<a name="l00189"></a>00189         <span class="keywordflow">if</span> (size - minSize &lt;= maxSize - minSize) { 
<a name="l00190"></a>00190             <span class="keywordtype">size_t</span> i = (size - minSize + quantum - 1) / quantum;
<a name="l00191"></a>00191             Hole* hole = chains[i];
<a name="l00192"></a>00192             <span class="keywordflow">if</span> (hole != NULL) { 
<a name="l00193"></a>00193                 hits += 1;
<a name="l00194"></a>00194                 chains[i] = hole-&gt;next;
<a name="l00195"></a>00195                 hole-&gt;next = vacant;
<a name="l00196"></a>00196                 vacant = hole;
<a name="l00197"></a>00197                 <span class="keywordflow">return</span> hole-&gt;offs;
<a name="l00198"></a>00198             }            
<a name="l00199"></a>00199             faults += 1;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201         <span class="keywordflow">return</span> 0;
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203     
<a name="l00204"></a>00204     <span class="keywordtype">bool</span> deallocate(offs_t offs, <span class="keywordtype">size_t</span> size) { 
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (vacant != NULL &amp;&amp; size - minSize &lt;= maxSize - minSize) {             
<a name="l00206"></a>00206             <span class="keywordtype">size_t</span> i = (size - minSize + quantum - 1) / quantum;
<a name="l00207"></a>00207             Hole* hole = vacant;
<a name="l00208"></a>00208             vacant = hole-&gt;next;
<a name="l00209"></a>00209             hole-&gt;next = chains[i];
<a name="l00210"></a>00210             chains[i] = hole;
<a name="l00211"></a>00211             hole-&gt;offs = offs;
<a name="l00212"></a>00212             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00215"></a>00215     }   
<a name="l00216"></a>00216 };
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="keyword">class </span>dbMonitor { 
<a name="l00220"></a>00220   <span class="keyword">public</span>:
<a name="l00221"></a>00221     sharedsem_t sem;
<a name="l00222"></a>00222     sharedsem_t mutatorSem;
<a name="l00223"></a>00223     <span class="keywordtype">int</span>  nReaders;
<a name="l00224"></a>00224     <span class="keywordtype">int</span>  nWriters;
<a name="l00225"></a>00225     <span class="keywordtype">int</span>  nConcurrentWriters;
<a name="l00226"></a>00226     <span class="keywordtype">int</span>  nWaitReaders;
<a name="l00227"></a>00227     <span class="keywordtype">int</span>  nWaitWriters;
<a name="l00228"></a>00228     <span class="keywordtype">int</span>  waitForUpgrade;
<a name="l00229"></a>00229     <span class="keywordtype">int</span>  forceCommitCount;
<a name="l00230"></a>00230     <span class="keywordtype">int</span>  backupInProgress;
<a name="l00231"></a>00231     <span class="keywordtype">int</span>  uncommittedChanges;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordtype">int</span>  curr;             <span class="comment">// copy of header-&gt;root, used to allow read access </span>
<a name="l00234"></a>00234                            <span class="comment">// to the database during transaction commit</span>
<a name="l00235"></a>00235     offs_t size; <span class="comment">// database size</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordtype">int</span>  commitInProgress;
<a name="l00238"></a>00238     <span class="keywordtype">int</span>  concurrentTransId;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     <span class="keywordtype">unsigned</span> lastDeadlockRecoveryTime;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242     <span class="keywordtype">int</span>  version; 
<a name="l00243"></a>00243     <span class="keywordtype">int</span>  users;  
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     dbProcessId ownerPid;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     dbDatabaseThreadContext*  delayedCommitContext;     <span class="comment">// save context of delayed transaction</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     int4 dirtyPagesMap[dbDirtyPageBitmapSize/4];
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="keywordtype">int</span>  sharedLockOwner[dbMaxReaders];
<a name="l00252"></a>00252     <span class="keywordtype">int</span>  exclusiveLockOwner;
<a name="l00253"></a>00253     <span class="keywordtype">int</span>  clientId;
<a name="l00254"></a>00254     <span class="keywordtype">int</span>  upgradeId;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordtype">int</span>  modified;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="preprocessor">#ifdef DO_NOT_REUSE_OID_WITHIN_SESSION</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>    <span class="keyword">struct </span>{ 
<a name="l00260"></a>00260         oid_t head;
<a name="l00261"></a>00261         oid_t tail;
<a name="l00262"></a>00262     } sessionFreeList[2];
<a name="l00263"></a>00263 <span class="preprocessor">#endif</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>};
<a name="l00265"></a>00265 
<a name="l00269"></a><a class="code" href="classdbL2List.html">00269</a> <span class="keyword">class </span>FASTDB_DLL_ENTRY <a class="code" href="classdbL2List.html">dbL2List</a> { 
<a name="l00270"></a>00270   <span class="keyword">public</span>:
<a name="l00271"></a>00271     <a class="code" href="classdbL2List.html">dbL2List</a>* next; 
<a name="l00272"></a>00272     <a class="code" href="classdbL2List.html">dbL2List</a>* prev; 
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     <span class="keywordtype">void</span> link(<a class="code" href="classdbL2List.html">dbL2List</a>* elem) { 
<a name="l00275"></a>00275         elem-&gt;prev = <span class="keyword">this</span>;
<a name="l00276"></a>00276         elem-&gt;next = next;
<a name="l00277"></a>00277         next = next-&gt;prev = elem;
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     <span class="keywordtype">void</span> unlink() { 
<a name="l00280"></a>00280         next-&gt;prev = prev;
<a name="l00281"></a>00281         prev-&gt;next = next;
<a name="l00282"></a>00282         next = prev = <span class="keyword">this</span>;
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284     <span class="keywordtype">bool</span> isEmpty() { 
<a name="l00285"></a>00285         <span class="keywordflow">return</span> next == <span class="keyword">this</span>;
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287     <span class="keywordtype">void</span> reset() { 
<a name="l00288"></a>00288         next = prev = <span class="keyword">this</span>;
<a name="l00289"></a>00289     }        
<a name="l00290"></a>00290     <a class="code" href="classdbL2List.html">dbL2List</a>() { 
<a name="l00291"></a>00291         next = prev = <span class="keyword">this</span>;
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     ~<a class="code" href="classdbL2List.html">dbL2List</a>() { 
<a name="l00294"></a>00294         unlink();
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keyword">class </span>dbVisitedObject {
<a name="l00299"></a>00299   <span class="keyword">public</span>: 
<a name="l00300"></a>00300     dbVisitedObject* next;
<a name="l00301"></a>00301     oid_t            oid;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     dbVisitedObject(oid_t oid, dbVisitedObject* chain) {         
<a name="l00304"></a>00304         this-&gt;oid = oid;
<a name="l00305"></a>00305         next = chain;
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 };
<a name="l00308"></a>00308     
<a name="l00309"></a>00309 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span><span class="keyword">struct </span>dbWatchDogContext : <a class="code" href="classdbL2List.html">dbL2List</a> { 
<a name="l00311"></a>00311     dbThread    thread;
<a name="l00312"></a>00312     dbWatchDog  watchDog;
<a name="l00313"></a>00313     <span class="keywordtype">int</span>         clientId;
<a name="l00314"></a>00314     <a class="code" href="classdbDatabase.html">dbDatabase</a>* db;
<a name="l00315"></a>00315     dbMutex*    mutex;
<a name="l00316"></a>00316 };
<a name="l00317"></a>00317 <span class="preprocessor">#endif</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>
<a name="l00322"></a><a class="code" href="classdbTransactionLogger.html">00322</a> <span class="keyword">class </span><a class="code" href="classdbTransactionLogger.html">dbTransactionLogger</a> 
<a name="l00323"></a>00323 {
<a name="l00324"></a>00324   <span class="keyword">public</span>:
<a name="l00333"></a>00333     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbTransactionLogger.html#ad87ad43273b0dcc60a15d3484708f55f">insert</a>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid, <a class="code" href="classdbRecord.html">dbRecord</a> <span class="keyword">const</span>* dbsObj, <span class="keywordtype">void</span> <span class="keyword">const</span>* appObj) = 0;
<a name="l00334"></a>00334 
<a name="l00343"></a>00343     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbTransactionLogger.html#a8cc5d10ace1087296834a472004c3c0e">update</a>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid, <a class="code" href="classdbRecord.html">dbRecord</a> <span class="keyword">const</span>* dbsObj, <span class="keywordtype">void</span> <span class="keyword">const</span>* appObj) = 0;
<a name="l00344"></a>00344 
<a name="l00351"></a>00351     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <span class="keyword">remove</span>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid) = 0;
<a name="l00352"></a>00352 
<a name="l00357"></a>00357     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbTransactionLogger.html#a355b94103283d578b21f065cd6c050a7">commitPhase1</a>() = 0;
<a name="l00358"></a>00358 
<a name="l00362"></a>00362     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdbTransactionLogger.html#aafa9ac881c949f7eb0f2b29b49544a06">commitPhase2</a>() = 0;
<a name="l00363"></a>00363 
<a name="l00367"></a>00367     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdbTransactionLogger.html#aa5aade20974cba85510abde9643d1331">rollback</a>() = 0;
<a name="l00368"></a>00368 };
<a name="l00369"></a>00369 
<a name="l00373"></a><a class="code" href="classdbFileTransactionLogger.html">00373</a> <span class="keyword">class </span><a class="code" href="classdbFileTransactionLogger.html">dbFileTransactionLogger</a> : <span class="keyword">public</span> <a class="code" href="classdbTransactionLogger.html">dbTransactionLogger</a>
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375     dbFile log;
<a name="l00376"></a>00376     <span class="keywordtype">char</span>*  buf;
<a name="l00377"></a>00377     <span class="keywordtype">size_t</span> used;
<a name="l00378"></a>00378     <span class="keywordtype">size_t</span> allocated;
<a name="l00379"></a>00379     <span class="keywordtype">bool</span>   crc;
<a name="l00380"></a>00380 
<a name="l00384"></a>00384     <span class="keyword">enum</span> OperationKind {
<a name="l00385"></a>00385         opInsert, 
<a name="l00386"></a>00386         opUpdate,
<a name="l00387"></a>00387         opRemove
<a name="l00388"></a>00388     };
<a name="l00389"></a>00389     <span class="keywordtype">void</span> append(OperationKind kind, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid, <a class="code" href="classdbRecord.html">dbRecord</a> <span class="keyword">const</span>* body);
<a name="l00390"></a>00390     <span class="keywordtype">char</span>* extend(<span class="keywordtype">size_t</span> size);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="keyword">public</span>:
<a name="l00393"></a>00393     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbFileTransactionLogger.html#a35d0c45182c6f590579a60d4be7daf9a">insert</a>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid, <a class="code" href="classdbRecord.html">dbRecord</a> <span class="keyword">const</span>* dbsObj, <span class="keywordtype">void</span> <span class="keyword">const</span>* appObj);
<a name="l00394"></a>00394     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbFileTransactionLogger.html#a08a3d82012fa552fd0e1ebc8d00c9abc">update</a>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid, <a class="code" href="classdbRecord.html">dbRecord</a> <span class="keyword">const</span>* dbsObj, <span class="keywordtype">void</span> <span class="keyword">const</span>* appObj);
<a name="l00395"></a>00395     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <span class="keyword">remove</span>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid);
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdbFileTransactionLogger.html#ad102080b231c6d3fe87de3edc6d9f7b6">commitPhase1</a>();
<a name="l00398"></a>00398     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdbFileTransactionLogger.html#aa9a840c0e7c094816e0261df910bcbfc">commitPhase2</a>();
<a name="l00399"></a>00399     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdbFileTransactionLogger.html#a726a8de5b93f7794eaf2706ebf0e3dd7">rollback</a>();
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <a class="code" href="classdbFileTransactionLogger.html">dbFileTransactionLogger</a>();
<a name="l00402"></a>00402     <span class="keyword">virtual</span>~<a class="code" href="classdbFileTransactionLogger.html">dbFileTransactionLogger</a>();
<a name="l00403"></a>00403     
<a name="l00404"></a>00404 
<a name="l00411"></a>00411     <span class="keywordtype">bool</span> <a class="code" href="classdbFileTransactionLogger.html#ae3226b8063859d78888509ee639e9ff0">open</a>(char_t <span class="keyword">const</span>* path, <span class="keywordtype">int</span> flags = dbFile::no_sync, <span class="keywordtype">bool</span> crc = <span class="keyword">true</span>);
<a name="l00412"></a>00412     
<a name="l00416"></a>00416     <span class="keywordtype">void</span> <a class="code" href="classdbFileTransactionLogger.html#a4f7abd86de43b8283085ae190dd7aa1e">close</a>();
<a name="l00417"></a>00417     
<a name="l00418"></a>00418     <span class="keyword">enum</span> RestoreStatus
<a name="l00419"></a>00419     {
<a name="l00420"></a>00420         rsOK,
<a name="l00421"></a>00421         rsCRCMismatch,
<a name="l00422"></a>00422         rsReadFailed,
<a name="l00423"></a>00423         rsTableNotFound,
<a name="l00424"></a>00424         rsOIDMismatch
<a name="l00425"></a>00425     };
<a name="l00426"></a>00426 
<a name="l00433"></a>00433     RestoreStatus <a class="code" href="classdbFileTransactionLogger.html#a4fdd7adc190cd3707afb4def5b1a263f">restore</a>(<a class="code" href="classdbDatabase.html">dbDatabase</a>&amp; db, <span class="keywordtype">size_t</span>&amp; nTrans);
<a name="l00434"></a>00434 };
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
<a name="l00437"></a>00437 <span class="keyword">class </span>dbHArray;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="keyword">class </span>dbXmlContext;
<a name="l00440"></a>00440 <span class="keyword">class </span>dbXmlScanner;
<a name="l00441"></a>00441 
<a name="l00445"></a><a class="code" href="classdbDatabase.html">00445</a> <span class="keyword">class </span>FASTDB_DLL_ENTRY <a class="code" href="classdbDatabase.html">dbDatabase</a> 
<a name="l00446"></a>00446 { 
<a name="l00447"></a>00447     <span class="keyword">friend</span> <span class="keyword">class </span>dbSelection;
<a name="l00448"></a>00448     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>;
<a name="l00449"></a>00449     <span class="keyword">friend</span> <span class="keyword">class </span>dbHashTable;
<a name="l00450"></a>00450     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbQuery.html">dbQuery</a>;
<a name="l00451"></a>00451     <span class="keyword">friend</span> <span class="keyword">class </span>dbTtree;
<a name="l00452"></a>00452     <span class="keyword">friend</span> <span class="keyword">class </span>dbTtreeNode;
<a name="l00453"></a>00453     <span class="keyword">friend</span> <span class="keyword">class </span>dbRtree;
<a name="l00454"></a>00454     <span class="keyword">friend</span> <span class="keyword">class </span>dbRtreePage;
<a name="l00455"></a>00455     <span class="keyword">friend</span> <span class="keyword">class </span>dbParallelQueryContext; 
<a name="l00456"></a>00456     <span class="keyword">friend</span> <span class="keyword">class </span>dbServer;
<a name="l00457"></a>00457     <span class="keyword">friend</span> <span class="keyword">class </span>dbColumnBinding;
<a name="l00458"></a>00458     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbUserFunctionArgument.html">dbUserFunctionArgument</a>;
<a name="l00459"></a>00459     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbAnyContainer.html">dbAnyContainer</a>;
<a name="l00460"></a>00460     <span class="keyword">friend</span> <span class="keyword">class </span>dbFile;
<a name="l00461"></a>00461     <span class="keyword">friend</span> <span class="keyword">class </span>dbCLI;
<a name="l00462"></a>00462     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbFileTransactionLogger.html">dbFileTransactionLogger</a>;
<a name="l00463"></a>00463     <span class="keyword">friend</span> <span class="keyword">class </span>GiSTdb;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="preprocessor">#ifdef HAS_TEMPLATE_FRIENDS</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
<a name="l00467"></a>00467     <span class="keyword">friend</span> <span class="keyword">class </span>dbHArray;
<a name="l00468"></a>00468 <span class="preprocessor">#else</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>    <span class="keyword">friend</span> <span class="keyword">class </span>dbAnyHArray;
<a name="l00470"></a>00470 <span class="preprocessor">#endif</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>
<a name="l00472"></a>00472   <span class="keyword">public</span>:
<a name="l00482"></a>00482     <span class="keywordtype">bool</span> open(char_t <span class="keyword">const</span>* databaseName, 
<a name="l00483"></a>00483               char_t <span class="keyword">const</span>* fileName = NULL, 
<a name="l00484"></a>00484               time_t waitLockTimeoutMsec = INFINITE, 
<a name="l00485"></a>00485               time_t commitDelaySec = 0);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="keyword">enum</span> dbAccessType { 
<a name="l00488"></a>00488         dbReadOnly,
<a name="l00489"></a>00489         dbAllAccess,
<a name="l00490"></a>00490         dbConcurrentRead,
<a name="l00491"></a>00491         dbConcurrentUpdate
<a name="l00492"></a>00492     };
<a name="l00493"></a>00493 
<a name="l00497"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html">00497</a>     <span class="keyword">struct </span><a class="code" href="structdbDatabase_1_1OpenParameters.html">OpenParameters</a> { 
<a name="l00501"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#ab2fd5838b2c63b8eeb486621b1ce99b4">00501</a>         char_t <span class="keyword">const</span>* databaseName;
<a name="l00502"></a>00502 
<a name="l00506"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#aa7aa4274c842ea3135670943f292206a">00506</a>         char_t <span class="keyword">const</span>* databaseFilePath;
<a name="l00507"></a>00507         
<a name="l00511"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#aa36316be5a6c71b19dd5e84653cdfe09">00511</a>         time_t  transactionCommitDelay;
<a name="l00512"></a>00512 
<a name="l00516"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a433710453f10d84abb0e7edf89639833">00516</a>         time_t waitLockTimeoutMsec;
<a name="l00517"></a>00517 
<a name="l00521"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a2b11d89d7b74644f6536bcc197d5c82f">00521</a>         dbAccessType accessType;
<a name="l00522"></a>00522 
<a name="l00526"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a1cd0be4a5e37db1d2ca669e1b7d645d2">00526</a>         <span class="keywordtype">size_t</span> initSize;
<a name="l00527"></a>00527 
<a name="l00531"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a1585558ed4f9169b634804ed498f395f">00531</a>         <span class="keywordtype">size_t</span> extensionQuantum;
<a name="l00532"></a>00532             
<a name="l00536"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#af199f461aa50895f1a4edef5e78a18f4">00536</a>         <span class="keywordtype">size_t</span> initIndexSize;
<a name="l00537"></a>00537 
<a name="l00541"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a283e8ac729f820d2ac21726355b5f215">00541</a>         <span class="keywordtype">int</span> nThreads;
<a name="l00542"></a>00542 
<a name="l00547"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a8239abcbf52787085a8c6432eab5021f">00547</a>         offs_t freeSpaceReuseThreshold;
<a name="l00548"></a>00548 
<a name="l00552"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a01d42f4aa2a81105001644c3085b9c72">00552</a>         <span class="keywordtype">int</span> parallelScanThreshold;
<a name="l00553"></a>00553 
<a name="l00557"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a4d3e310f8ab138a14a7e046b8aa07af4">00557</a>         <span class="keywordtype">int</span> nodeId;
<a name="l00558"></a>00558 
<a name="l00562"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#ac9435a356ff228941a0c4abde18ac084">00562</a>         <span class="keywordtype">char</span>** nodeAddresses;
<a name="l00563"></a>00563 
<a name="l00567"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#aef90528775fc225ae15b377d2e7b8dbe">00567</a>         <span class="keywordtype">int</span> nNodes;
<a name="l00568"></a>00568         
<a name="l00572"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a0592bedcf64fc96f18c2179bc61cf23d">00572</a>         <span class="keywordtype">int</span> pollInterval; <span class="comment">// milliseconds</span>
<a name="l00573"></a>00573 
<a name="l00577"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#ac68318ab1de867b05b91895635c21e5d">00577</a>         <span class="keywordtype">int</span> waitReadyTimeout; <span class="comment">// milliseconds</span>
<a name="l00578"></a>00578 
<a name="l00582"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a119e907b673e633bcbae0ab216197c8d">00582</a>         <span class="keywordtype">int</span> waitStatusTimeout; <span class="comment">// milliseconds </span>
<a name="l00583"></a>00583 
<a name="l00587"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a1a5dd5a96ffde8a0713654525222386a">00587</a>         <span class="keywordtype">int</span> recoveryConnectionAttempts; 
<a name="l00588"></a>00588 
<a name="l00592"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a41973ac23955892f5383bb1140bbbb09">00592</a>         <span class="keywordtype">int</span> startupConnectionAttempts;
<a name="l00593"></a>00593 
<a name="l00599"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a14aa298ba587292b12aa60438a528a36">00599</a>         <span class="keywordtype">int</span> replicationWriteTimeout;
<a name="l00600"></a>00600 
<a name="l00606"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a9eedd58fc80cc8ed533beac503ae363b">00606</a>         <span class="keywordtype">int</span> maxAsyncRecoveryIterations;
<a name="l00607"></a>00607 
<a name="l00612"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#a1b48b99bb8d3541f18381f000c7e2637">00612</a>         <span class="keywordtype">int</span> fileOpenFlags;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614         <a class="code" href="structdbDatabase_1_1OpenParameters.html">OpenParameters</a>() { 
<a name="l00615"></a>00615             databaseName = NULL;
<a name="l00616"></a>00616             databaseFilePath = NULL;
<a name="l00617"></a>00617             transactionCommitDelay = 0;
<a name="l00618"></a>00618             waitLockTimeoutMsec = INFINITE;
<a name="l00619"></a>00619             accessType = dbAllAccess;
<a name="l00620"></a>00620             extensionQuantum = dbDefaultExtensionQuantum;
<a name="l00621"></a>00621             initSize = dbDefaultInitDatabaseSize;
<a name="l00622"></a>00622             initIndexSize = dbDefaultInitIndexSize;
<a name="l00623"></a>00623             nThreads = 1;
<a name="l00624"></a>00624             freeSpaceReuseThreshold = dbDefaultExtensionQuantum;
<a name="l00625"></a>00625             nodeId = 0;
<a name="l00626"></a>00626             nodeAddresses = NULL;
<a name="l00627"></a>00627             nNodes = 0;
<a name="l00628"></a>00628             parallelScanThreshold = dbDefaultParallelScanThreshold;
<a name="l00629"></a>00629             pollInterval = dbDefaultPollInterval;
<a name="l00630"></a>00630             waitReadyTimeout = dbWaitReadyTimeout;
<a name="l00631"></a>00631             waitStatusTimeout = dbWaitStatusTimeout;
<a name="l00632"></a>00632             recoveryConnectionAttempts = dbRecoveryConnectionAttempts; 
<a name="l00633"></a>00633             startupConnectionAttempts = dbStartupConnectionAttempts;
<a name="l00634"></a>00634             replicationWriteTimeout = dbReplicationWriteTimeout;
<a name="l00635"></a>00635             maxAsyncRecoveryIterations = dbMaxAsyncRecoveryIterations;   
<a name="l00636"></a>00636             fileOpenFlags = 0; 
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638     };
<a name="l00639"></a>00639 
<a name="l00645"></a>00645     <span class="keywordtype">bool</span> open(OpenParameters&amp; params);
<a name="l00646"></a>00646 
<a name="l00650"></a>00650     <span class="keywordtype">void</span> close();
<a name="l00651"></a>00651 
<a name="l00655"></a>00655     <span class="keywordtype">void</span> commit();
<a name="l00656"></a>00656 
<a name="l00661"></a>00661     <span class="keywordtype">void</span> precommit();
<a name="l00662"></a>00662     
<a name="l00666"></a>00666     <span class="keywordtype">void</span> rollback();
<a name="l00667"></a>00667 
<a name="l00674"></a>00674     <span class="keywordtype">void</span> scheduleBackup(char_t <span class="keyword">const</span>* fileName, time_t periodSec);
<a name="l00675"></a>00675     
<a name="l00680"></a>00680     <span class="keywordtype">void</span> attach();
<a name="l00681"></a>00681     
<a name="l00687"></a>00687     <span class="keywordtype">void</span> attach(dbDatabaseThreadContext* ctx);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 
<a name="l00690"></a>00690     <span class="keyword">enum</span> DetachFlags { 
<a name="l00691"></a>00691         COMMIT          = 1,
<a name="l00692"></a>00692         DESTROY_CONTEXT = 2
<a name="l00693"></a>00693     };
<a name="l00698"></a>00698     <span class="keywordtype">void</span> detach(<span class="keywordtype">int</span> flags = COMMIT|DESTROY_CONTEXT);
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="keyword">enum</span> dbLockType { 
<a name="l00701"></a>00701         dbSharedLock, 
<a name="l00702"></a>00702         dbExclusiveLock,
<a name="l00703"></a>00703         dbCommitLock
<a name="l00704"></a>00704     };
<a name="l00705"></a>00705 
<a name="l00709"></a><a class="code" href="classdbDatabase.html#aa4b3ded01bf4d66edaf6111abcf91f6d">00709</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#aa4b3ded01bf4d66edaf6111abcf91f6d">lock</a>(dbLockType lock = dbExclusiveLock) { beginTransaction(lock); }
<a name="l00710"></a>00710 
<a name="l00719"></a>00719     <span class="keywordtype">bool</span> backup(char_t <span class="keyword">const</span>* file, <span class="keywordtype">bool</span> compactify);
<a name="l00720"></a>00720     
<a name="l00730"></a>00730     <span class="keywordtype">bool</span> backup(dbFile* file, <span class="keywordtype">bool</span> compactify);
<a name="l00731"></a>00731     
<a name="l00736"></a><a class="code" href="classdbDatabase.html#a30ea1fd8a039904daed402e975a6ca01">00736</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#a30ea1fd8a039904daed402e975a6ca01">assign</a>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>&amp; desc) { 
<a name="l00737"></a>00737         assert(((<span class="keywordtype">void</span>)<span class="stringliteral">&quot;Table is not yet assigned to the database&quot;</span>, 
<a name="l00738"></a>00738                 desc.<a class="code" href="classdbTableDescriptor.html#a814c8235360343bef56ec8c04641c454">tableId</a> == 0));
<a name="l00739"></a>00739         desc.<a class="code" href="classdbTableDescriptor.html#ad3593b08f9a0d9e06489e2490f9c51d9">db</a> = <span class="keyword">this</span>; 
<a name="l00740"></a>00740         desc.<a class="code" href="classdbTableDescriptor.html#a3f6c3816ba616ea953605aed48fbbd08">fixedDatabase</a> = <span class="keyword">true</span>;
<a name="l00741"></a>00741     }
<a name="l00742"></a>00742 
<a name="l00750"></a>00750     <span class="keywordtype">void</span> setConcurrency(<span class="keywordtype">unsigned</span> nThreads);
<a name="l00751"></a>00751 
<a name="l00756"></a><a class="code" href="classdbDatabase.html#aa12a7f519b6b58179e875bd9bfe0394d">00756</a>     soffs_t <a class="code" href="classdbDatabase.html#aa12a7f519b6b58179e875bd9bfe0394d">getAllocatedSize</a>() { <span class="keywordflow">return</span> allocatedSize; }
<a name="l00757"></a>00757 
<a name="l00762"></a><a class="code" href="classdbDatabase.html#a7a9a7d4fef191fccaa8a7aa455763f3d">00762</a>     <span class="keywordtype">size_t</span> <a class="code" href="classdbDatabase.html#a7a9a7d4fef191fccaa8a7aa455763f3d">getDatabaseSize</a>() { <span class="keywordflow">return</span> header-&gt;size; }
<a name="l00763"></a>00763 
<a name="l00768"></a><a class="code" href="classdbDatabase.html#a4717133aa73ac66e169e2866db32b377">00768</a>     <span class="keywordtype">size_t</span> <a class="code" href="classdbDatabase.html#a4717133aa73ac66e169e2866db32b377">getUsedDatabaseSize</a>() { <span class="keywordflow">return</span> header-&gt;used; }
<a name="l00769"></a>00769 
<a name="l00774"></a><a class="code" href="classdbDatabase.html#a5fb3e20e210e40a33116a4c1372c98d1">00774</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#a5fb3e20e210e40a33116a4c1372c98d1">getNumberOfReaders</a>() { 
<a name="l00775"></a>00775         <span class="keywordflow">return</span> monitor-&gt;nReaders;
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 
<a name="l00782"></a><a class="code" href="classdbDatabase.html#ae4af4ad21e1d3465bc1d16699bd3c613">00782</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#ae4af4ad21e1d3465bc1d16699bd3c613">getNumberOfWriters</a>() { 
<a name="l00783"></a>00783         <span class="keywordflow">return</span> monitor-&gt;nWriters;
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 
<a name="l00790"></a><a class="code" href="classdbDatabase.html#a2c18de697f7111bca527a58c69b17c4d">00790</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#a2c18de697f7111bca527a58c69b17c4d">getNumberOfBlockedReaders</a>() { 
<a name="l00791"></a>00791         <span class="keywordflow">return</span> monitor-&gt;nReaders;
<a name="l00792"></a>00792     }
<a name="l00793"></a>00793 
<a name="l00798"></a><a class="code" href="classdbDatabase.html#a9c2336e08e59f1509304fe4934a80763">00798</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#a9c2336e08e59f1509304fe4934a80763">getNumberOfBlockedWriters</a>() { 
<a name="l00799"></a>00799         <span class="keywordflow">return</span> monitor-&gt;nWriters;
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801 
<a name="l00806"></a><a class="code" href="classdbDatabase.html#ad6a9ad3c0dbdf1055a7631c3a15be45f">00806</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#ad6a9ad3c0dbdf1055a7631c3a15be45f">getNumberOfUsers</a>() { 
<a name="l00807"></a>00807         <span class="keywordflow">return</span> monitor-&gt;users;
<a name="l00808"></a>00808     }
<a name="l00809"></a>00809 
<a name="l00817"></a><a class="code" href="classdbDatabase.html#a21997d7169d1b4382367933dcae056ed">00817</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#a21997d7169d1b4382367933dcae056ed">allowColumnsDeletion</a>(<span class="keywordtype">bool</span> enabled = <span class="keyword">true</span>) { 
<a name="l00818"></a>00818         confirmDeleteColumns = enabled;
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820 
<a name="l00828"></a><a class="code" href="classdbDatabase.html#adccfd5692158b4653bd1fc9518bc29f1">00828</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#adccfd5692158b4653bd1fc9518bc29f1">enableCascadeDelete</a>(<span class="keywordtype">bool</span> enabled = <span class="keyword">true</span>) { 
<a name="l00829"></a>00829         cascadeDelete = enabled;
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831 
<a name="l00836"></a><a class="code" href="classdbDatabase.html#af1563fbac602be6f226dee65f09ea19b">00836</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#af1563fbac602be6f226dee65f09ea19b">enableInverseReferencesUpdate</a>(<span class="keywordtype">bool</span> enabled = <span class="keyword">true</span>) { 
<a name="l00837"></a>00837         inverseReferencesUpdate = enabled;
<a name="l00838"></a>00838     }
<a name="l00839"></a>00839 
<a name="l00847"></a>00847     <span class="keywordtype">bool</span> prepareQuery(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     <span class="keyword">enum</span> dbErrorClass { 
<a name="l00850"></a>00850         NoError, 
<a name="l00851"></a>00851         QueryError,
<a name="l00852"></a>00852         ArithmeticError,
<a name="l00853"></a>00853         IndexOutOfRangeError,
<a name="l00854"></a>00854         DatabaseOpenError,
<a name="l00855"></a>00855         FileError,
<a name="l00856"></a>00856         OutOfMemoryError,
<a name="l00857"></a>00857         Deadlock,
<a name="l00858"></a>00858         NullReferenceError,
<a name="l00859"></a>00859         LockRevoked,
<a name="l00860"></a>00860         FileLimitExeeded,
<a name="l00861"></a>00861         InconsistentInverseReference,
<a name="l00862"></a>00862         DatabaseReadOnly,
<a name="l00863"></a>00863         AssertionFailed,
<a name="l00864"></a>00864         AccessToDeletedObject,
<a name="l00865"></a>00865         NoCurrentRecord,
<a name="l00866"></a>00866         ReadonlyCursor,
<a name="l00867"></a>00867         IncompatibleSchemaChange,
<a name="l00868"></a>00868         RejectedByTransactionLogger
<a name="l00869"></a>00869     };
<a name="l00870"></a>00870     <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> errorMessage[];
<a name="l00871"></a>00871     <span class="keyword">typedef</span> void (*dbErrorHandler)(<span class="keywordtype">int</span> error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg, <span class="keywordtype">int</span> msgarg, <span class="keywordtype">void</span>* context); 
<a name="l00872"></a>00872 
<a name="l00879"></a>00879     dbErrorHandler setErrorHandler(dbErrorHandler newHandler, <span class="keywordtype">void</span>* errorHandlerContext = NULL);
<a name="l00880"></a>00880 
<a name="l00886"></a>00886     <span class="keywordtype">void</span> setTransactionLogger(<a class="code" href="classdbTransactionLogger.html">dbTransactionLogger</a>* logger);
<a name="l00887"></a>00887 
<a name="l00895"></a>00895     <span class="keyword">virtual</span> <span class="keywordtype">void</span> handleError(dbErrorClass error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg = NULL, 
<a name="l00896"></a>00896                              <span class="keywordtype">int</span> arg = 0); 
<a name="l00897"></a>00897 
<a name="l00906"></a>00906     <span class="keyword">virtual</span> <span class="keywordtype">void</span> formatErrorMessage(<span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span> bufSize, dbErrorClass error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg = NULL, <span class="keywordtype">int</span> arg = 0); 
<a name="l00907"></a>00907 
<a name="l00911"></a>00911     <span class="keyword">virtual</span> <span class="keywordtype">void</span> fatalError();
<a name="l00912"></a>00912 
<a name="l00919"></a>00919     <span class="keywordtype">void</span> insertRecord(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, <a class="code" href="classdbAnyReference.html">dbAnyReference</a>* ref, 
<a name="l00920"></a>00920                       <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
<a name="l00921"></a>00921 
<a name="l00925"></a><a class="code" href="classdbDatabase.html#ad593afbaa222cd1e0aef3bde11c657f8">00925</a>     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#ad593afbaa222cd1e0aef3bde11c657f8">isOpen</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opened; }
<a name="l00926"></a>00926 
<a name="l00930"></a>00930         <span class="keywordtype">bool</span> isInWriteTransaction();
<a name="l00931"></a>00931 
<a name="l00935"></a>00935     <span class="keywordtype">bool</span> isCommitted();
<a name="l00936"></a>00936 
<a name="l00940"></a>00940     <span class="keywordtype">bool</span> isAttached();
<a name="l00941"></a>00941 
<a name="l00945"></a>00945     <span class="keywordtype">bool</span> isUpdateTransaction();
<a name="l00946"></a>00946 
<a name="l00950"></a>00950     <span class="keywordtype">int</span>  getVersion();
<a name="l00951"></a>00951 
<a name="l00956"></a><a class="code" href="classdbDatabase.html#abb2369383f441c2d61f7cdbb7df9323a">00956</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#abb2369383f441c2d61f7cdbb7df9323a">setFileSizeLimit</a>(<span class="keywordtype">size_t</span> limit) { 
<a name="l00957"></a>00957         fileSizeLimit = limit;
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 <span class="preprocessor">#ifdef FUZZY_CHECKPOINT</span>
<a name="l00961"></a>00961 <span class="preprocessor"></span>
<a name="l00966"></a>00966     <span class="keywordtype">void</span> setFuzzyCheckpointBuffer(<span class="keywordtype">size_t</span> nPages) { 
<a name="l00967"></a>00967         file.setCheckpointBufferSize(nPages);
<a name="l00968"></a>00968     }
<a name="l00969"></a>00969 <span class="preprocessor">#endif</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span>
<a name="l00971"></a>00971 <span class="preprocessor">#ifndef NO_MEMBER_TEMPLATES</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>
<a name="l00977"></a>00977     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00978"></a><a class="code" href="classdbDatabase.html#a0197e7171cdf3d667277d82051d135ec">00978</a>     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> <a class="code" href="classdbDatabase.html#a0197e7171cdf3d667277d82051d135ec">insert</a>(T <span class="keyword">const</span>&amp; record) {
<a name="l00979"></a>00979         <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
<a name="l00980"></a>00980         insertRecord(lookupTable(&amp;T::dbDescriptor), &amp;ref, &amp;record);
<a name="l00981"></a>00981         <span class="keywordflow">return</span> ref;
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983 <span class="preprocessor">#endif</span>
<a name="l00984"></a>00984 <span class="preprocessor"></span>
<a name="l00990"></a>00990     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* lookupTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l00991"></a>00991 
<a name="l00996"></a>00996     <span class="keywordtype">void</span> getMemoryStatistic(dbMemoryStatistic&amp; stat);
<a name="l00997"></a>00997 
<a name="l01002"></a><a class="code" href="classdbDatabase.html#a9c5b3727f694984ca54bd898c6a8d4d6">01002</a>     <span class="keywordtype">int</span> <a class="code" href="classdbDatabase.html#a9c5b3727f694984ca54bd898c6a8d4d6">getNumberOfProceededTransactions</a>() { 
<a name="l01003"></a>01003         <span class="keywordflow">return</span> monitor-&gt;concurrentTransId - 1;
<a name="l01004"></a>01004     }
<a name="l01005"></a>01005 
<a name="l01011"></a><a class="code" href="classdbDatabase.html#a9dc333ec67ab1547791b95635b156ba0">01011</a>     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#a9dc333ec67ab1547791b95635b156ba0">isValidOid</a>(oid_t oid) { 
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (oid &lt; dbFirstUserId || oid &gt;= currIndexSize) {
<a name="l01013"></a>01013             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01014"></a>01014         }
<a name="l01015"></a>01015         <span class="keywordflow">return</span> !(currIndex[oid]&amp;(dbFreeHandleMarker|dbInternalObjectMarker));
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017 
<a name="l01024"></a>01024     <span class="keywordtype">void</span> exportDatabaseToXml(FILE* out, <span class="keywordtype">char</span> <span class="keyword">const</span>* encoding = <span class="stringliteral">&quot;UTF-8&quot;</span>);
<a name="l01025"></a>01025 
<a name="l01031"></a>01031     <span class="keywordtype">bool</span> importDatabaseFromXml(FILE* in);
<a name="l01032"></a>01032    
<a name="l01040"></a>01040     <span class="keywordtype">bool</span> exportDatabaseToXml(char_t <span class="keyword">const</span>* file, <span class="keywordtype">char</span> <span class="keyword">const</span>* encoding = <span class="stringliteral">&quot;UTF-8&quot;</span>);
<a name="l01041"></a>01041 
<a name="l01048"></a>01048     <span class="keywordtype">bool</span> importDatabaseFromXml(char_t <span class="keyword">const</span>* file);
<a name="l01049"></a>01049    
<a name="l01050"></a>01050 <span class="preprocessor">#ifdef PROFILE</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span>
<a name="l01055"></a>01055     <span class="keyword">static</span> <span class="keywordtype">void</span> profile(<span class="keywordtype">char</span> <span class="keyword">const</span>* file);
<a name="l01056"></a>01056 
<a name="l01061"></a>01061     <span class="keyword">static</span> <span class="keywordtype">void</span> profile(FILE* file);
<a name="l01062"></a>01062 <span class="preprocessor">#endif</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span>
<a name="l01071"></a><a class="code" href="classdbDatabase.html#a8524c1b921beca3ff9470fffbebae2e7">01071</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#a8524c1b921beca3ff9470fffbebae2e7">setFixedSizeAllocator</a>(<span class="keywordtype">size_t</span> minSize, <span class="keywordtype">size_t</span> maxSize, <span class="keywordtype">size_t</span> quantum, <span class="keywordtype">size_t</span> bufSize) { 
<a name="l01072"></a>01072         fixedSizeAllocator.init(minSize, maxSize, quantum, bufSize);
<a name="l01073"></a>01073     }
<a name="l01074"></a>01074 
<a name="l01085"></a>01085     <span class="keywordtype">void</span> recoverFreeOidList();
<a name="l01086"></a>01086 
<a name="l01087"></a>01087     <span class="keyword">enum</span> dbThreadMode {
<a name="l01088"></a>01088         dbNotUsePthreads,
<a name="l01089"></a>01089         dbUsePthreads
<a name="l01090"></a>01090     };
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="keyword">enum</span> dbReplicationMode {
<a name="l01093"></a>01093         dbReplicated,
<a name="l01094"></a>01094         dbStandalone
<a name="l01095"></a>01095     };
<a name="l01096"></a>01096        
<a name="l01108"></a>01108     <a class="code" href="classdbDatabase.html">dbDatabase</a>(dbAccessType type = dbAllAccess,
<a name="l01109"></a>01109                <span class="keywordtype">size_t</span> dbInitSize = dbDefaultInitDatabaseSize,
<a name="l01110"></a>01110                <span class="keywordtype">size_t</span> dbExtensionQuantum = dbDefaultExtensionQuantum,
<a name="l01111"></a>01111                <span class="keywordtype">size_t</span> dbInitIndexSize = dbDefaultInitIndexSize,
<a name="l01112"></a>01112                <span class="keywordtype">int</span> nThreads = 1 
<a name="l01113"></a>01113                <span class="comment">// Do not specify the following parameter - them are used only for checking</span>
<a name="l01114"></a>01114                <span class="comment">// that application and FastDB library were built with the </span>
<a name="l01115"></a>01115                <span class="comment">// same compiler options (-DNO_PTHREADS and -REPPLICATION_SUPPORT)</span>
<a name="l01116"></a>01116                <span class="comment">// Mismached parameters should cause linker error</span>
<a name="l01117"></a>01117 #ifdef NO_PTHREADS
<a name="l01118"></a>01118                , dbThreadMode threadMode = dbNotUsePthreads
<a name="l01119"></a>01119 #endif
<a name="l01120"></a>01120 #ifdef REPLICATION_SUPPORT
<a name="l01121"></a>01121                , dbReplicationMode replicationMode = dbReplicated
<a name="l01122"></a>01122 #endif
<a name="l01123"></a>01123                );
<a name="l01127"></a>01127     <span class="keyword">virtual</span> ~<a class="code" href="classdbDatabase.html">dbDatabase</a>(); 
<a name="l01128"></a>01128 
<a name="l01135"></a>01135     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* findTableByName(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     
<a name="l01143"></a>01143     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* findTableByID(oid_t <span class="keywordtype">id</span>);
<a name="l01144"></a>01144 
<a name="l01149"></a><a class="code" href="classdbDatabase.html#af46a0616cda64750e1a67c16c5d00afc">01149</a>     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* <a class="code" href="classdbDatabase.html#af46a0616cda64750e1a67c16c5d00afc">getTables</a>() { 
<a name="l01150"></a>01150         <span class="keywordflow">return</span> tables;
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153     <span class="keywordtype">int</span>    fileOpenFlags;
<a name="l01154"></a>01154     dbAccessType accessType;
<a name="l01155"></a>01155     <span class="keywordtype">size_t</span> initSize;
<a name="l01156"></a>01156     <span class="keywordtype">size_t</span> extensionQuantum;
<a name="l01157"></a>01157     <span class="keywordtype">size_t</span> initIndexSize;
<a name="l01158"></a>01158     offs_t freeSpaceReuseThreshold;
<a name="l01159"></a>01159 
<a name="l01160"></a>01160   <span class="keyword">protected</span>:
<a name="l01161"></a>01161     <span class="keyword">static</span> <span class="keywordtype">size_t</span> internalObjectSize[];
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     dbThreadPool threadPool;
<a name="l01164"></a>01164 
<a name="l01165"></a>01165     FixedSizeAllocator fixedSizeAllocator;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167     dbThreadContext&lt;dbDatabaseThreadContext&gt; threadContext;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169     byte*     baseAddr;         <span class="comment">// base address of database file mapping</span>
<a name="l01170"></a>01170     <a class="code" href="classdbHeader.html">dbHeader</a>* header;           <span class="comment">// database header information</span>
<a name="l01171"></a>01171     offs_t*   currIndex;        <span class="comment">// current database object index</span>
<a name="l01172"></a>01172     offs_t*   index[2];
<a name="l01173"></a>01173     <span class="keywordtype">unsigned</span>  parThreads;
<a name="l01174"></a>01174     <span class="keywordtype">bool</span>      modified;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     <span class="keywordtype">size_t</span>    currRBitmapPage;  <span class="comment">//current bitmap page for allocating records</span>
<a name="l01177"></a>01177     <span class="keywordtype">size_t</span>    currRBitmapOffs;  <span class="comment">//offset in current bitmap page for allocating</span>
<a name="l01178"></a>01178                                 <span class="comment">//unaligned records</span>
<a name="l01179"></a>01179     <span class="keywordtype">size_t</span>    currPBitmapPage;  <span class="comment">//current bitmap page for allocating page objects</span>
<a name="l01180"></a>01180     <span class="keywordtype">size_t</span>    currPBitmapOffs;  <span class="comment">//offset in current bitmap page for allocating</span>
<a name="l01181"></a>01181                                 <span class="comment">//page objects</span>
<a name="l01182"></a>01182     <span class="keyword">struct </span>dbLocation { 
<a name="l01183"></a>01183         offs_t      pos;
<a name="l01184"></a>01184         <span class="keywordtype">size_t</span>      size;
<a name="l01185"></a>01185         dbLocation* next;
<a name="l01186"></a>01186     };
<a name="l01187"></a>01187     dbLocation* reservedChain;
<a name="l01188"></a>01188     
<a name="l01189"></a>01189     char_t*   databaseName;
<a name="l01190"></a>01190     <span class="keywordtype">int</span>       databaseNameLen;
<a name="l01191"></a>01191     char_t*   fileName;
<a name="l01192"></a>01192     <span class="keywordtype">int</span>       version;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     <span class="keywordtype">size_t</span>    committedIndexSize;
<a name="l01195"></a>01195     <span class="keywordtype">size_t</span>    currIndexSize;
<a name="l01196"></a>01196     oid_t     updatedRecordId;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198     <span class="keywordtype">unsigned</span>  waitLockTimeout;
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     <span class="keywordtype">size_t</span>    fileSizeLimit;
<a name="l01201"></a>01201     <span class="keywordtype">bool</span>      uncommittedChanges;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203     dbFile                    file;
<a name="l01204"></a>01204     dbSharedObject&lt;dbMonitor&gt; shm;
<a name="l01205"></a>01205     dbGlobalCriticalSection   cs;
<a name="l01206"></a>01206     dbGlobalCriticalSection   mutatorCS;
<a name="l01207"></a>01207     dbInitializationMutex     initMutex;
<a name="l01208"></a>01208     dbSemaphore               writeSem; 
<a name="l01209"></a>01209     dbSemaphore               readSem; 
<a name="l01210"></a>01210     dbSemaphore               upgradeSem; 
<a name="l01211"></a>01211     dbEvent                   backupCompletedEvent;
<a name="l01212"></a>01212     dbMonitor*                monitor;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>*        tables;
<a name="l01215"></a>01215 
<a name="l01216"></a>01216     <span class="keywordtype">int</span>*                      bitmapPageAvailableSpace;
<a name="l01217"></a>01217     <span class="keywordtype">bool</span>                      opened;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     soffs_t                   allocatedSize;
<a name="l01220"></a>01220     offs_t                    deallocatedSize;
<a name="l01221"></a>01221     
<a name="l01222"></a>01222     time_t                    commitDelay;     
<a name="l01223"></a>01223     time_t                    commitTimeout;
<a name="l01224"></a>01224     time_t                    commitTimerStarted;
<a name="l01225"></a>01225     
<a name="l01226"></a>01226     dbMutex                   delayedCommitStartTimerMutex;
<a name="l01227"></a>01227     dbMutex                   delayedCommitStopTimerMutex;
<a name="l01228"></a>01228     dbLocalEvent              delayedCommitStartTimerEvent; 
<a name="l01229"></a>01229     dbEvent                   delayedCommitStopTimerEvent; 
<a name="l01230"></a>01230     dbLocalEvent              commitThreadSyncEvent;
<a name="l01231"></a>01231     <span class="keywordtype">bool</span>                      delayedCommitEventsOpened;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     dbMutex                   backupMutex;    
<a name="l01234"></a>01234     dbLocalEvent              backupInitEvent;
<a name="l01235"></a>01235     char_t*                   backupFileName;
<a name="l01236"></a>01236     time_t                    backupPeriod;
<a name="l01237"></a>01237     <span class="keywordtype">bool</span>                      stopDelayedCommitThread;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     dbThread                  backupThread;
<a name="l01240"></a>01240     dbThread                  commitThread;
<a name="l01241"></a>01241  
<a name="l01242"></a>01242     <span class="keywordtype">int</span>                       accessCount;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     <a class="code" href="classdbL2List.html">dbL2List</a>                  threadContextList;
<a name="l01245"></a>01245     dbMutex                   threadContextListMutex;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     dbErrorHandler            errorHandler;
<a name="l01248"></a>01248     <span class="keywordtype">void</span>*                     errorHandlerContext;   
<a name="l01249"></a>01249 
<a name="l01250"></a>01250     <a class="code" href="classdbTransactionLogger.html">dbTransactionLogger</a>*      logger;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     <span class="keywordtype">int</span>                       schemeVersion;
<a name="l01253"></a>01253     dbVisitedObject*          visitedChain;
<a name="l01254"></a>01254 
<a name="l01255"></a>01255     <span class="keywordtype">bool</span>                      confirmDeleteColumns;
<a name="l01256"></a>01256     <span class="keywordtype">bool</span>                      cascadeDelete;
<a name="l01257"></a>01257     <span class="keywordtype">bool</span>                      inverseReferencesUpdate;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     <span class="keywordtype">int</span>                       maxClientId;
<a name="l01260"></a>01260     <span class="keywordtype">int</span>                       selfId;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     dbXmlContext*             xmlContext;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
<a name="l01265"></a>01265 <span class="preprocessor"></span>    dbWatchDog                selfWatchDog;
<a name="l01266"></a>01266     <a class="code" href="classdbL2List.html">dbL2List</a>                  watchDogThreadContexts;
<a name="l01267"></a>01267     dbMutex*                  watchDogMutex;
<a name="l01268"></a>01268 <span class="preprocessor">#endif</span>
<a name="l01269"></a>01269 <span class="preprocessor"></span>    
<a name="l01270"></a>01270     <span class="keywordtype">unsigned</span> parallelScanThreshold; 
<a name="l01271"></a>01271     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* tableHash[dbTableHashSize];
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     <span class="keywordtype">void</span> exportScheme(FILE* out);
<a name="l01274"></a>01274     <span class="keywordtype">void</span> exportClass(FILE* out, <span class="keywordtype">char</span>* name, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fieldList);
<a name="l01275"></a>01275    
<a name="l01276"></a>01276     oid_t mapId(<span class="keywordtype">long</span> <span class="keywordtype">id</span>);
<a name="l01277"></a>01277     <span class="keywordtype">bool</span> importField(<span class="keywordtype">char</span>* terminator, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, byte* rec, dbXmlScanner&amp; scanner);
<a name="l01278"></a>01278     <span class="keywordtype">bool</span> importRecord(<span class="keywordtype">char</span>* terminator, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fieldList, byte* rec, dbXmlScanner&amp; scanner);
<a name="l01279"></a>01279     <span class="keywordtype">void</span> insertRecord(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t oid, <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
<a name="l01280"></a>01280 
<a name="l01286"></a>01286     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* loadMetaTable();
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <span class="keywordtype">void</span> cleanup(dbInitializationMutex::initializationStatus status, <span class="keywordtype">int</span> step);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="keywordtype">void</span> delayedCommit();
<a name="l01291"></a>01291     <span class="keywordtype">void</span> backupScheduler();
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc delayedCommitProc(<span class="keywordtype">void</span>* arg) { 
<a name="l01294"></a>01294         ((<a class="code" href="classdbDatabase.html">dbDatabase</a>*)arg)-&gt;delayedCommit();
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc backupSchedulerProc(<span class="keywordtype">void</span>* arg) { 
<a name="l01298"></a>01298         ((<a class="code" href="classdbDatabase.html">dbDatabase</a>*)arg)-&gt;backupScheduler();
<a name="l01299"></a>01299     }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isReplicated();
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="keyword">virtual</span> <span class="keywordtype">void</span> close0();
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
<a name="l01306"></a>01306 <span class="preprocessor"></span>
<a name="l01310"></a>01310     <span class="keywordtype">void</span> revokeLock(<span class="keywordtype">int</span> clientId);
<a name="l01311"></a>01311 
<a name="l01316"></a>01316     <span class="keyword">static</span> <span class="keywordtype">void</span> watchDogThread(dbWatchDogContext* ctx);
<a name="l01317"></a>01317 
<a name="l01321"></a>01321     <span class="keywordtype">void</span> startWatchDogThreads();
<a name="l01322"></a>01322 <span class="preprocessor">#endif</span>
<a name="l01323"></a>01323 <span class="preprocessor"></span>    
<a name="l01327"></a>01327     <span class="keywordtype">void</span> addLockOwner();
<a name="l01328"></a>01328 
<a name="l01332"></a>01332     <span class="keywordtype">void</span> removeLockOwner(<span class="keywordtype">int</span> clientId);
<a name="l01333"></a>01333 
<a name="l01338"></a>01338     <span class="keywordtype">void</span> commit(dbDatabaseThreadContext* ctx);
<a name="l01339"></a>01339 
<a name="l01344"></a>01344     <span class="keywordtype">void</span> restoreTablesConsistency();
<a name="l01345"></a>01345 
<a name="l01351"></a><a class="code" href="classdbDatabase.html#a7bff04ecc071c89a2e9d27fda8cd326e">01351</a>     <a class="code" href="classdbRecord.html">dbRecord</a>* <a class="code" href="classdbDatabase.html#a7bff04ecc071c89a2e9d27fda8cd326e">getRow</a>(oid_t oid) { 
<a name="l01352"></a>01352         <span class="keywordflow">if</span> (currIndex[oid]&amp;(dbFreeHandleMarker|dbInternalObjectMarker)) {
<a name="l01353"></a>01353             handleError(dbDatabase::AccessToDeletedObject);
<a name="l01354"></a>01354         }
<a name="l01355"></a>01355         <span class="keywordflow">return</span> (<a class="code" href="classdbRecord.html">dbRecord</a>*)(baseAddr + currIndex[oid]); 
<a name="l01356"></a>01356     }
<a name="l01357"></a>01357 
<a name="l01367"></a>01367     <a class="code" href="classdbRecord.html">dbRecord</a>* putRow(oid_t oid, <span class="keywordtype">size_t</span> newSize); 
<a name="l01368"></a>01368 
<a name="l01374"></a><a class="code" href="classdbDatabase.html#adf6df8cfd2f7aed207acda7d344e2701">01374</a>     <a class="code" href="classdbRecord.html">dbRecord</a>* <a class="code" href="classdbDatabase.html#adf6df8cfd2f7aed207acda7d344e2701">putRow</a>(oid_t oid) { 
<a name="l01375"></a>01375         <span class="keywordflow">if</span> (oid &lt; committedIndexSize &amp;&amp; index[0][oid] == index[1][oid]) { 
<a name="l01376"></a>01376             <span class="keywordtype">size_t</span> size = getRow(oid)-&gt;<a class="code" href="classdbRecord.html#a1de5ddb030858d2ee3125cd7f1e64075">size</a>;
<a name="l01377"></a>01377             <span class="keywordtype">size_t</span> pageNo = oid/dbHandlesPerPage;
<a name="l01378"></a>01378             monitor-&gt;dirtyPagesMap[pageNo &gt;&gt; 5] |= 1 &lt;&lt; (pageNo &amp; 31);
<a name="l01379"></a>01379             cloneBitmap(currIndex[oid], size);
<a name="l01380"></a>01380             allocate(size, oid);
<a name="l01381"></a>01381         } 
<a name="l01382"></a>01382         <span class="keywordflow">return</span> (<a class="code" href="classdbRecord.html">dbRecord</a>*)(baseAddr + currIndex[oid]); 
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384 
<a name="l01390"></a><a class="code" href="classdbDatabase.html#a0f15caecea63b2da73defcf52b9731e6">01390</a>     byte* <span class="keyword">get</span>(oid_t oid) { 
<a name="l01391"></a>01391         <span class="keywordflow">return</span> baseAddr + (currIndex[oid] &amp; ~dbInternalObjectMarker); 
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393 
<a name="l01399"></a><a class="code" href="classdbDatabase.html#a8e762278f8441f945fb1251cfa337a9b">01399</a>     byte* <a class="code" href="classdbDatabase.html#a8e762278f8441f945fb1251cfa337a9b">put</a>(oid_t oid) { 
<a name="l01400"></a>01400         <span class="keywordflow">if</span> (oid &lt; committedIndexSize &amp;&amp; index[0][oid] == index[1][oid]) { 
<a name="l01401"></a>01401             offs_t offs = currIndex[oid];
<a name="l01402"></a>01402             <span class="keywordtype">size_t</span> size = internalObjectSize[offs &amp; dbInternalObjectMarker];
<a name="l01403"></a>01403             <span class="keywordtype">size_t</span> pageNo = oid/dbHandlesPerPage;
<a name="l01404"></a>01404             monitor-&gt;dirtyPagesMap[pageNo &gt;&gt; 5] |= 1 &lt;&lt; (pageNo &amp; 31);
<a name="l01405"></a>01405             allocate(size, oid);
<a name="l01406"></a>01406             cloneBitmap(offs &amp; ~dbInternalObjectMarker, size);
<a name="l01407"></a>01407         } 
<a name="l01408"></a>01408         <span class="keywordflow">return</span> baseAddr + (currIndex[oid] &amp; ~dbInternalObjectMarker); 
<a name="l01409"></a>01409     }
<a name="l01410"></a>01410     
<a name="l01424"></a>01424     <span class="keywordtype">bool</span> isPrefixSearch(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
<a name="l01425"></a>01425                         dbExprNode* expr, dbExprNode* andExpr, 
<a name="l01426"></a>01426                         <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* &amp;indexedField);
<a name="l01427"></a>01427 
<a name="l01441"></a>01441     <span class="keywordtype">bool</span> isIndexApplicable(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
<a name="l01442"></a>01442                            dbExprNode* expr, dbExprNode* andExpr, 
<a name="l01443"></a>01443                            <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* &amp;indexedField);
<a name="l01444"></a>01444 
<a name="l01456"></a>01456     <span class="keywordtype">bool</span> isIndexApplicable(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
<a name="l01457"></a>01457                            dbExprNode* expr, dbExprNode* andExpr);
<a name="l01458"></a>01458 
<a name="l01471"></a>01471     <span class="keywordtype">bool</span> followInverseReference(dbExprNode* expr, dbExprNode* andExpr, 
<a name="l01472"></a>01472                                 <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, oid_t iref);
<a name="l01473"></a>01473 
<a name="l01481"></a>01481     <span class="keywordtype">bool</span> existsInverseReference(dbExprNode* expr, <span class="keywordtype">int</span> nExistsClauses);
<a name="l01482"></a>01482 
<a name="l01488"></a>01488     <span class="keywordtype">bool</span> existsIndexedReference(dbExprNode* expr);
<a name="l01489"></a>01489 
<a name="l01499"></a>01499     <span class="keyword">static</span> <span class="keywordtype">void</span> _fastcall execute(dbExprNode* expr, 
<a name="l01500"></a>01500                                   dbInheritedAttribute&amp; iattr,
<a name="l01501"></a>01501                                   dbSynthesizedAttribute&amp; sattr);
<a name="l01502"></a>01502 
<a name="l01512"></a>01512     <span class="keywordtype">bool</span> evaluate(dbExprNode* expr, oid_t oid, <a class="code" href="classdbTable.html">dbTable</a>* table, <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor);
<a name="l01513"></a>01513 
<a name="l01518"></a>01518     <span class="keywordtype">void</span> select(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor);
<a name="l01519"></a>01519 
<a name="l01525"></a>01525     <span class="keywordtype">void</span> select(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
<a name="l01526"></a>01526 
<a name="l01532"></a>01532     <span class="keywordtype">void</span> traverse(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
<a name="l01533"></a>01533 
<a name="l01540"></a>01540     <span class="keywordtype">void</span> update(oid_t oid, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
<a name="l01541"></a>01541     
<a name="l01547"></a>01547     <span class="keywordtype">void</span> <span class="keyword">remove</span>(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid);
<a name="l01548"></a>01548 
<a name="l01556"></a>01556     offs_t allocate(<span class="keywordtype">size_t</span> size, oid_t oid = 0);
<a name="l01557"></a>01557 
<a name="l01563"></a>01563     <span class="keywordtype">void</span> deallocate(offs_t pos, <span class="keywordtype">size_t</span> size);
<a name="l01564"></a>01564 
<a name="l01570"></a>01570     <span class="keywordtype">void</span> extend(offs_t size);
<a name="l01571"></a>01571 
<a name="l01577"></a>01577     <span class="keywordtype">void</span> cloneBitmap(offs_t pos, <span class="keywordtype">size_t</span> size);
<a name="l01578"></a>01578 
<a name="l01585"></a>01585     oid_t allocateId(<span class="keywordtype">int</span> n = 1);
<a name="l01586"></a>01586 
<a name="l01593"></a>01593     <span class="keywordtype">void</span> freeId(oid_t oid, <span class="keywordtype">int</span> n = 1);
<a name="l01594"></a>01594 
<a name="l01600"></a>01600     <span class="keywordtype">void</span> updateCursors(oid_t oid, <span class="keywordtype">bool</span> removed = <span class="keyword">false</span>);
<a name="l01601"></a>01601     
<a name="l01605"></a>01605     <span class="keywordtype">void</span> recovery();
<a name="l01606"></a>01606 
<a name="l01615"></a>01615     <span class="keywordtype">bool</span> checkVersion();
<a name="l01616"></a>01616 
<a name="l01622"></a><a class="code" href="classdbDatabase.html#afc0381681c1378b2bfd5d5078045eea2">01622</a>     oid_t <a class="code" href="classdbDatabase.html#afc0381681c1378b2bfd5d5078045eea2">allocateObject</a>(dbInternalObject marker) {
<a name="l01623"></a>01623         oid_t oid = allocateId();
<a name="l01624"></a>01624         offs_t pos = allocate(internalObjectSize[marker]) + marker;
<a name="l01625"></a>01625         currIndex[oid] = pos;
<a name="l01626"></a>01626         <span class="keywordflow">return</span> oid;
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628 
<a name="l01635"></a><a class="code" href="classdbDatabase.html#a56838815ecf19269f58d19de695a2e7a">01635</a>     oid_t allocateRow(oid_t tableId, <span class="keywordtype">size_t</span> size)
<a name="l01636"></a>01636     {
<a name="l01637"></a>01637         oid_t oid = allocateId();
<a name="l01638"></a>01638         allocateRow(tableId, oid, size);
<a name="l01639"></a>01639         <span class="keywordflow">return</span> oid;
<a name="l01640"></a>01640     }
<a name="l01641"></a>01641     
<a name="l01649"></a>01649     <span class="keywordtype">void</span> allocateRow(oid_t tableId, oid_t oid, <span class="keywordtype">size_t</span> size);
<a name="l01650"></a>01650 
<a name="l01656"></a>01656     <span class="keywordtype">void</span> freeRow(oid_t tableId, oid_t oid);
<a name="l01657"></a>01657 
<a name="l01661"></a>01661     <span class="keywordtype">void</span> freeObject(oid_t oid); 
<a name="l01662"></a>01662     
<a name="l01666"></a>01666     <span class="keyword">static</span> <span class="keywordtype">void</span> deleteCompiledQuery(dbExprNode* tree); 
<a name="l01667"></a>01667 
<a name="l01674"></a>01674     <span class="keywordtype">bool</span> beginTransaction(dbLockType lock);
<a name="l01675"></a>01675 
<a name="l01679"></a><a class="code" href="classdbDatabase.html#a9acf4cd1d0bb15ff2c5f9d39549d2ee3">01679</a>     <span class="keywordtype">void</span> <a class="code" href="classdbDatabase.html#a9acf4cd1d0bb15ff2c5f9d39549d2ee3">endTransaction</a>() { 
<a name="l01680"></a>01680         endTransaction(threadContext.get());
<a name="l01681"></a>01681     }
<a name="l01682"></a>01682     
<a name="l01687"></a>01687     <span class="keywordtype">void</span> endTransaction(dbDatabaseThreadContext* ctx);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="keyword">virtual</span> <span class="keywordtype">void</span> waitTransactionAcknowledgement();
<a name="l01690"></a>01690 
<a name="l01695"></a>01695     <span class="keywordtype">void</span> initializeMetaTable();
<a name="l01696"></a>01696     
<a name="l01704"></a>01704     <span class="keywordtype">bool</span> loadScheme(<span class="keywordtype">bool</span> alter);
<a name="l01705"></a>01705 
<a name="l01711"></a>01711     <span class="keywordtype">bool</span> completeDescriptorsInitialization();
<a name="l01712"></a>01712 
<a name="l01718"></a>01718     <span class="keywordtype">void</span> reformatTable(oid_t tableId, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l01719"></a>01719 
<a name="l01727"></a>01727     <span class="keywordtype">bool</span> addIndices(<span class="keywordtype">bool</span> alter, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l01728"></a>01728 
<a name="l01734"></a>01734     oid_t addNewTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l01735"></a>01735 
<a name="l01741"></a>01741     <span class="keywordtype">void</span> updateTableDescriptor(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t tableId);
<a name="l01742"></a>01742 
<a name="l01751"></a>01751     <span class="keywordtype">void</span> insertInverseReference(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, 
<a name="l01752"></a>01752                                 oid_t reverseId, oid_t targetId);
<a name="l01753"></a>01753 
<a name="l01759"></a>01759     <span class="keywordtype">void</span> removeInverseReferences(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t oid);
<a name="l01760"></a>01760 
<a name="l01769"></a>01769     <span class="keywordtype">void</span> removeInverseReference(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, 
<a name="l01770"></a>01770                                 oid_t reverseId, oid_t targetId);
<a name="l01771"></a>01771 
<a name="l01776"></a>01776     <span class="keywordtype">void</span> deleteTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l01777"></a>01777 
<a name="l01782"></a>01782     <span class="keywordtype">void</span> dropTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
<a name="l01783"></a>01783 
<a name="l01788"></a>01788     <span class="keywordtype">void</span> createIndex(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
<a name="l01789"></a>01789 
<a name="l01794"></a>01794     <span class="keywordtype">void</span> createHashTable(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
<a name="l01795"></a>01795 
<a name="l01800"></a>01800     <span class="keywordtype">void</span> dropIndex(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
<a name="l01801"></a>01801 
<a name="l01806"></a>01806     <span class="keywordtype">void</span> dropHashTable(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
<a name="l01807"></a>01807 
<a name="l01813"></a>01813     <span class="keywordtype">void</span> linkTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t tableId);
<a name="l01814"></a>01814 
<a name="l01819"></a>01819     <span class="keywordtype">void</span> unlinkTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table);
<a name="l01820"></a>01820 
<a name="l01827"></a>01827     <span class="keywordtype">bool</span> wasReserved(offs_t pos, <span class="keywordtype">size_t</span> size);
<a name="l01828"></a>01828 
<a name="l01837"></a>01837     <span class="keywordtype">void</span> reserveLocation(dbLocation&amp; location, offs_t pos, <span class="keywordtype">size_t</span> size);
<a name="l01838"></a>01838 
<a name="l01843"></a>01843     <span class="keywordtype">void</span> commitLocation();
<a name="l01844"></a>01844 
<a name="l01850"></a>01850     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* findTable(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
<a name="l01851"></a>01851     
<a name="l01855"></a>01855     <span class="keywordtype">void</span> setDirty();
<a name="l01856"></a>01856 
<a name="l01862"></a>01862     <span class="keywordtype">bool</span> isFree(offs_t pos, <span class="keywordtype">int</span> objBitSize);
<a name="l01863"></a>01863 
<a name="l01869"></a>01869     <span class="keywordtype">void</span> markAsAllocated(offs_t pos, <span class="keywordtype">int</span> objBitSize);
<a name="l01870"></a>01870 
<a name="l01871"></a>01871 };
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 
<a name="l01874"></a>01874 <span class="preprocessor">#ifdef REPLICATION_SUPPORT</span>
<a name="l01875"></a>01875 <span class="preprocessor"></span>
<a name="l01876"></a>01876 <span class="preprocessor">#include &quot;sockio.h&quot;</span>
<a name="l01877"></a>01877 
<a name="l01878"></a>01878 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbConnection { 
<a name="l01879"></a>01879  <span class="keyword">public</span>:
<a name="l01880"></a>01880     socket_t*    reqSock;
<a name="l01881"></a>01881     socket_t*    respSock;
<a name="l01882"></a>01882     dbLocalEvent statusEvent;
<a name="l01883"></a>01883     dbLocalEvent readyEvent;
<a name="l01884"></a>01884     dbLocalEvent useEvent;
<a name="l01885"></a>01885     dbLocalEvent committedEvent;
<a name="l01886"></a>01886     dbMutex      writeCS;
<a name="l01887"></a>01887     <span class="keywordtype">int</span>          useCount;
<a name="l01888"></a>01888     <span class="keywordtype">int</span>          waitUseEventFlag;
<a name="l01889"></a>01889     <span class="keywordtype">int</span>          waitStatusEventFlag;
<a name="l01890"></a>01890     <span class="keywordtype">int</span>          status;
<a name="l01891"></a>01891     <span class="keywordtype">int</span>          updateCounter;
<a name="l01892"></a>01892     <span class="keywordtype">int</span>          nRecoveredPages;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894     dbConnection() { 
<a name="l01895"></a>01895         readyEvent.open();
<a name="l01896"></a>01896         useEvent.open();
<a name="l01897"></a>01897         statusEvent.open();
<a name="l01898"></a>01898         committedEvent.open();
<a name="l01899"></a>01899         useCount = 0;
<a name="l01900"></a>01900         waitUseEventFlag = 0;
<a name="l01901"></a>01901         waitStatusEventFlag = 0;
<a name="l01902"></a>01902         status = 0;
<a name="l01903"></a>01903         reqSock = respSock = NULL;
<a name="l01904"></a>01904         nRecoveredPages = 0;
<a name="l01905"></a>01905     }
<a name="l01906"></a>01906     ~dbConnection() { 
<a name="l01907"></a>01907         readyEvent.close();
<a name="l01908"></a>01908         useEvent.close();
<a name="l01909"></a>01909         statusEvent.close();
<a name="l01910"></a>01910         committedEvent.close();
<a name="l01911"></a>01911         <span class="keyword">delete</span> reqSock;
<a name="l01912"></a>01912         <span class="keyword">delete</span> respSock;
<a name="l01913"></a>01913     }
<a name="l01914"></a>01914 }; 
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbReplicatedDatabase : <span class="keyword">public</span> <a class="code" href="classdbDatabase.html">dbDatabase</a> {
<a name="l01917"></a>01917     <span class="keyword">friend</span> <span class="keyword">class </span>dbFile;
<a name="l01918"></a>01918   <span class="keyword">protected</span>:
<a name="l01919"></a>01919     <span class="keywordtype">char</span>**        serverURL;
<a name="l01920"></a>01920     <span class="keywordtype">int</span>           nServers;
<a name="l01921"></a>01921     <span class="keywordtype">int</span>           id;
<a name="l01922"></a>01922     dbConnection* con;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     <span class="keyword">enum</span> NodeStatus { 
<a name="l01925"></a>01925         ST_OFFLINE,  <span class="comment">// node is not available </span>
<a name="l01926"></a>01926         ST_ONLINE,   <span class="comment">// node is available </span>
<a name="l01927"></a>01927         ST_ACTIVE,   <span class="comment">// primary node is running, replicating changes</span>
<a name="l01928"></a>01928         ST_STANDBY,  <span class="comment">// standby node receives changes from primary node</span>
<a name="l01929"></a>01929         ST_RECOVERED <span class="comment">// node is recovered after the fault</span>
<a name="l01930"></a>01930     };
<a name="l01931"></a>01931     
<a name="l01932"></a>01932     dbLocalEvent  startEvent;
<a name="l01933"></a>01933     dbLocalEvent  recoveredEvent;
<a name="l01934"></a>01934     dbMutex       startCS;
<a name="l01935"></a>01935     dbMutex       commitCS;
<a name="l01936"></a>01936     fd_set        inputSD;
<a name="l01937"></a>01937     <span class="keywordtype">int</span>           nInputSD;
<a name="l01938"></a>01938 
<a name="l01939"></a>01939     <span class="keywordtype">int</span>           activeNodeId;
<a name="l01940"></a>01940     <span class="keywordtype">int</span>           masterNodeId;
<a name="l01941"></a>01941     <span class="keywordtype">bool</span>          onlineRecovery;
<a name="l01942"></a>01942     <span class="keywordtype">bool</span>          handshake; 
<a name="l01943"></a>01943     dbMutex       sockCS;
<a name="l01944"></a>01944     socket_t*     acceptSock;
<a name="l01945"></a>01945     dbThread      readerThread;
<a name="l01946"></a>01946 
<a name="l01947"></a>01947     <span class="keywordtype">int</span> pollInterval;
<a name="l01948"></a>01948     <span class="keywordtype">int</span> waitReadyTimeout;
<a name="l01949"></a>01949     <span class="keywordtype">int</span> waitStatusTimeout;
<a name="l01950"></a>01950     <span class="keywordtype">int</span> recoveryConnectionAttempts;
<a name="l01951"></a>01951     <span class="keywordtype">int</span> startupConnectionAttempts;
<a name="l01952"></a>01952     <span class="keywordtype">int</span> replicationWriteTimeout;
<a name="l01953"></a>01953     <span class="keywordtype">int</span> maxAsyncRecoveryIterations;
<a name="l01954"></a>01954 
<a name="l01955"></a>01955     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc startReader(<span class="keywordtype">void</span>* arg);
<a name="l01956"></a>01956 
<a name="l01957"></a>01957     <span class="keywordtype">void</span> waitTransactionAcknowledgement();
<a name="l01958"></a>01958 
<a name="l01959"></a>01959     <span class="keywordtype">void</span> reader();
<a name="l01960"></a>01960     <span class="keyword">virtual</span> <span class="keywordtype">void</span> close0();
<a name="l01961"></a>01961     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isReplicated();
<a name="l01962"></a>01962 
<a name="l01963"></a>01963   <span class="keyword">public</span>:
<a name="l01964"></a>01964     <span class="keywordtype">void</span> deleteConnection(<span class="keywordtype">int</span> nodeId);
<a name="l01965"></a>01965     <span class="keywordtype">void</span> lockConnection(<span class="keywordtype">int</span> nodeId);
<a name="l01966"></a>01966     <span class="keywordtype">void</span> unlockConnection(<span class="keywordtype">int</span> nodeId);
<a name="l01967"></a>01967     <span class="keywordtype">void</span> changeActiveNode();
<a name="l01968"></a>01968     <span class="keywordtype">void</span> addConnection(<span class="keywordtype">int</span> nodeId, socket_t* s);
<a name="l01969"></a>01969     <span class="keywordtype">bool</span> writeReq(<span class="keywordtype">int</span> nodeId, ReplicationRequest <span class="keyword">const</span>&amp; hdr, 
<a name="l01970"></a>01970                   <span class="keywordtype">void</span>* body = NULL, <span class="keywordtype">size_t</span> bodySize = 0);
<a name="l01971"></a>01971     <span class="keywordtype">bool</span> writeResp(<span class="keywordtype">int</span> nodeId, ReplicationRequest <span class="keyword">const</span>&amp; hdr);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#a7292d5348484aa6e90ff5da3c94e01ff">open</a>(<span class="keywordtype">char</span> <span class="keyword">const</span>* databaseName, <span class="keywordtype">char</span> <span class="keyword">const</span>* fileName,
<a name="l01974"></a>01974               <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keywordtype">char</span>* servers[], <span class="keywordtype">int</span> nServers);
<a name="l01975"></a>01975     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#a7292d5348484aa6e90ff5da3c94e01ff">open</a>(OpenParameters&amp; params);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     <span class="keywordtype">int</span> getNumberOfOnlineNodes();
<a name="l01978"></a>01978 
<a name="l01979"></a>01979     dbReplicatedDatabase(dbAccessType type = dbAllAccess,
<a name="l01980"></a>01980                          <span class="keywordtype">size_t</span> dbInitSize = dbDefaultInitDatabaseSize,
<a name="l01981"></a>01981                          <span class="keywordtype">size_t</span> dbExtensionQuantum = dbDefaultExtensionQuantum,
<a name="l01982"></a>01982                          <span class="keywordtype">size_t</span> dbInitIndexSize = dbDefaultInitIndexSize,
<a name="l01983"></a>01983                          <span class="keywordtype">int</span> nThreads = 1);
<a name="l01984"></a>01984 };
<a name="l01985"></a>01985 <span class="preprocessor">#endif</span>
<a name="l01986"></a>01986 <span class="preprocessor"></span>
<a name="l01987"></a>01987 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01988"></a>01988 <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> insert(T <span class="keyword">const</span>&amp; record) { 
<a name="l01989"></a>01989     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
<a name="l01990"></a>01990     T::dbDescriptor.getDatabase()-&gt;insertRecord(&amp;T::dbDescriptor, &amp;ref, &amp;record);
<a name="l01991"></a>01991     <span class="keywordflow">return</span> ref;
<a name="l01992"></a>01992 }
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 <span class="preprocessor">#ifdef NO_MEMBER_TEMPLATES</span>
<a name="l01995"></a>01995 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l01996"></a>01996 <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> insert(<a class="code" href="classdbDatabase.html">dbDatabase</a>&amp; db, T <span class="keyword">const</span>&amp; record) {
<a name="l01997"></a>01997     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
<a name="l01998"></a>01998     db.<a class="code" href="classdbDatabase.html#a9de489204ef31d019e9eaa66e210c2e4">insertRecord</a>(db.<a class="code" href="classdbDatabase.html#aba63d5c461f4c374e204b1cf9dc97f53">lookupTable</a>(&amp;T::dbDescriptor), &amp;ref, &amp;record);
<a name="l01999"></a>01999     <span class="keywordflow">return</span> ref;
<a name="l02000"></a>02000 }
<a name="l02001"></a>02001 <span class="preprocessor">#endif</span>
<a name="l02002"></a>02002 <span class="preprocessor"></span>
<a name="l02006"></a><a class="code" href="classdbSearchContext.html">02006</a> <span class="keyword">class </span><a class="code" href="classdbSearchContext.html">dbSearchContext</a> { 
<a name="l02007"></a>02007   <span class="keyword">public</span>:
<a name="l02008"></a>02008     <a class="code" href="classdbDatabase.html">dbDatabase</a>*        db;
<a name="l02009"></a>02009     dbExprNode*        condition;
<a name="l02010"></a>02010     <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>*       cursor;
<a name="l02011"></a>02011     <span class="keywordtype">char</span>*              firstKey;
<a name="l02012"></a>02012     <span class="keywordtype">int</span>                firstKeyInclusion;
<a name="l02013"></a>02013     <span class="keywordtype">char</span>*              lastKey;
<a name="l02014"></a>02014     <span class="keywordtype">int</span>                lastKeyInclusion;
<a name="l02015"></a>02015     <span class="keywordtype">int</span>                type;
<a name="l02016"></a>02016     <span class="keywordtype">int</span>                prefixLength;
<a name="l02017"></a>02017     <span class="keywordtype">int</span>                offs;
<a name="l02018"></a>02018     <span class="keywordtype">int</span>                probes;
<a name="l02019"></a>02019     <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* field;
<a name="l02020"></a>02020 };
<a name="l02021"></a>02021 
<a name="l02022"></a>02022 
<a name="l02023"></a>02023 
<a name="l02024"></a>02024 END_FASTDB_NAMESPACE
<a name="l02025"></a>02025 
<a name="l02026"></a>02026 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Aug 22 2010 23:57:51 for FastDB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
