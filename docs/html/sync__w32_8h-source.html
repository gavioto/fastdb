<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sync_w32.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>sync_w32.h</h1><div class="fragment"><pre>00001 <span class="comment">//-&lt; SYNC_W32.H &gt;----------------------------------------------------*--------*</span>
00002 <span class="comment">// FastDB                    Version 1.0         (c) 1999  GARRET    *     ?  *</span>
00003 <span class="comment">// (Main Memory Database Management System)                          *   /\|  *</span>
00004 <span class="comment">//                                                                   *  /  \  *</span>
00005 <span class="comment">//                          Created:     20-Nov-98    K.A. Knizhnik  * / [] \ *</span>
00006 <span class="comment">//                          Last update: 20-Dec-98    K.A. Knizhnik  * GARRET *</span>
00007 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00008 <span class="comment">// Intertask synchonization primitives</span>
00009 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00010 
00011 <span class="preprocessor">#ifndef __SYNC_W32_H__</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define __SYNC_W32_H__</span>
00013 <span class="preprocessor"></span>
00014 BEGIN_FASTDB_NAMESPACE
00015 
00016 <span class="preprocessor">#ifdef SET_NULL_DACL</span>
00017 <span class="preprocessor"></span><span class="keyword">class </span>FASTDB_DLL_ENTRY dbNullSecurityDesciptor { 
00018   <span class="keyword">public</span>:
00019     SECURITY_DESCRIPTOR sd;
00020     SECURITY_ATTRIBUTES sa; 
00021 
00022     dbNullSecurityDesciptor() { 
00023         InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION);
00024         SetSecurityDescriptorDacl(&amp;sd, TRUE, NULL, FALSE);
00025         sa.nLength = <span class="keyword">sizeof</span>(sa);
00026         sa.bInheritHandle = TRUE; 
00027         sa.lpSecurityDescriptor = &amp;sd;
00028     }
00029     
00030     <span class="keyword">static</span> dbNullSecurityDesciptor instance;
00031 };
00032 <span class="preprocessor">#define FASTDB_SECURITY_ATTRIBUTES &amp;dbNullSecurityDesciptor::instance.sa</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#else    </span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define FASTDB_SECURITY_ATTRIBUTES NULL</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbMutex { 
00038     CRITICAL_SECTION cs;
00039     <span class="keywordtype">bool</span>             initialized;
00040   <span class="keyword">public</span>:
00041     dbMutex() {
00042         InitializeCriticalSection(&amp;cs);
00043         initialized = <span class="keyword">true</span>;
00044     }
00045     ~dbMutex() {
00046         DeleteCriticalSection(&amp;cs);
00047         initialized = <span class="keyword">false</span>;
00048     }
00049     <span class="keywordtype">bool</span> isInitialized() { 
00050         <span class="keywordflow">return</span> initialized;
00051     }
00052     <span class="keywordtype">void</span> lock() {
00053         <span class="keywordflow">if</span> (initialized) { 
00054             EnterCriticalSection(&amp;cs);
00055         }
00056     }
00057     <span class="keywordtype">void</span> unlock() {
00058         <span class="keywordflow">if</span> (initialized) { 
00059             LeaveCriticalSection(&amp;cs);
00060         }
00061     }
00062 };
00063 
00064 <span class="preprocessor">#define thread_proc WINAPI</span>
00065 <span class="preprocessor"></span>
00066 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbThread { 
00067     HANDLE h;
00068   <span class="keyword">public</span>:
00069     <span class="keyword">typedef</span> void (thread_proc* thread_proc_t)(<span class="keywordtype">void</span>*);
00070 
00071     <span class="keyword">static</span> <span class="keywordtype">void</span> sleep(time_t sec) { 
00072         Sleep((DWORD)(sec*1000));
00073     }
00074 
00075 
00076     <span class="keywordtype">void</span> create(thread_proc_t f, <span class="keywordtype">void</span>* arg) { 
00077         DWORD threadid;
00078         h = CreateThread(FASTDB_SECURITY_ATTRIBUTES, 0, LPTHREAD_START_ROUTINE(f), arg,
00079                          0, &amp;threadid);
00080     }
00081     <span class="keyword">enum</span> ThreadPriority { 
00082         THR_PRI_LOW, 
00083         THR_PRI_HIGH
00084     };
00085 
00086     <span class="keywordtype">void</span> setPriority(ThreadPriority pri) { 
00087         SetThreadPriority(h, pri == THR_PRI_LOW ? THREAD_PRIORITY_IDLE : THREAD_PRIORITY_HIGHEST);
00088     }
00089         
00090     <span class="keywordtype">void</span> join() { 
00091         WaitForSingleObject(h, INFINITE);
00092         CloseHandle(h);
00093         h = NULL;
00094     }
00095     <span class="keywordtype">void</span> detach() { 
00096         <span class="keywordflow">if</span> (h != NULL) { 
00097             CloseHandle(h);
00098             h = NULL;
00099         }
00100     }   
00101     dbThread() { 
00102         h = NULL; 
00103     }
00104     ~dbThread() { 
00105         <span class="keywordflow">if</span> (h != NULL) { 
00106             CloseHandle(h);
00107         }
00108     }
00109     <span class="keyword">static</span> <span class="keywordtype">int</span> numberOfProcessors() { 
00110 <span class="preprocessor">#ifdef PHAR_LAP</span>
00111 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 1;
00112 <span class="preprocessor">#else</span>
00113 <span class="preprocessor"></span>        SYSTEM_INFO sysinfo;
00114         GetSystemInfo(&amp;sysinfo);
00115         <span class="keywordflow">return</span> sysinfo.dwNumberOfProcessors;
00116 <span class="preprocessor">#endif</span>
00117 <span class="preprocessor"></span>    }
00118 };
00119     
00120 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbProcessId { 
00121     DWORD tid;
00122   <span class="keyword">public</span>:
00123     <span class="keywordtype">bool</span> operator != (dbProcessId <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{ 
00124         <span class="keywordflow">return</span> tid != other.tid;
00125     }
00126 
00127     <span class="keywordtype">void</span> clear() { 
00128         tid = 0;
00129     }
00130 
00131     <span class="keyword">static</span> dbProcessId getCurrent() {
00132         dbProcessId curr;
00133         curr.tid = GetCurrentThreadId();
00134         <span class="keywordflow">return</span> curr;
00135     }
00136 };
00137 
00138 
00139 
00140 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbInitializationMutex { 
00141     HANDLE m;
00142   <span class="keyword">public</span>: 
00143     <span class="keyword">enum</span> initializationStatus { 
00144         InitializationError, 
00145         AlreadyInitialized,
00146         NotYetInitialized
00147     };
00148     initializationStatus initialize(<span class="keywordtype">char</span> <span class="keyword">const</span>* name) { 
00149         initializationStatus status;
00150         m = CreateMutex(FASTDB_SECURITY_ATTRIBUTES, <span class="keyword">true</span>, W32_STRING(name));
00151         <span class="keywordflow">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) { 
00152             status = WaitForSingleObject(m, INFINITE) == WAIT_OBJECT_0 
00153                    ? AlreadyInitialized : InitializationError;
00154             ReleaseMutex(m);
00155         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m != NULL) { 
00156             status = NotYetInitialized;
00157         } <span class="keywordflow">else</span> { 
00158             status = InitializationError;
00159         }
00160         <span class="keywordflow">return</span> status;
00161     }
00162     <span class="keywordtype">void</span> done() { 
00163         ReleaseMutex(m);
00164     }
00165     <span class="keywordtype">bool</span> close() {
00166         CloseHandle(m);
00167         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00168     }
00169     <span class="keywordtype">void</span> erase() { 
00170         close();
00171     }
00172     dbInitializationMutex() { 
00173         m = NULL;
00174     }
00175 };
00176 
00177 
00178 <span class="keyword">const</span> <span class="keywordtype">int</span> dbMaxSemValue = 1000000;
00179 
00180 
00181 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbSemaphore { 
00182   <span class="keyword">protected</span>:
00183     HANDLE s;
00184   <span class="keyword">public</span>:
00185     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec = INFINITE) { 
00186         <span class="keywordtype">int</span> rc = WaitForSingleObject(s, msec);
00187         assert(rc == WAIT_OBJECT_0 || rc == WAIT_TIMEOUT);
00188         <span class="keywordflow">return</span> rc == WAIT_OBJECT_0;
00189     }
00190     <span class="keywordtype">void</span> signal(<span class="keywordtype">unsigned</span> inc = 1) {
00191         <span class="keywordflow">if</span> (inc != 0) { 
00192             ReleaseSemaphore(s, inc, NULL);
00193         }
00194     }
00195     <span class="keywordtype">void</span> reset() { 
00196         <span class="keywordflow">while</span> (WaitForSingleObject(s, 0) == WAIT_OBJECT_0);
00197     }    
00198     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">unsigned</span> initValue = 0) {
00199         s = CreateSemaphore(FASTDB_SECURITY_ATTRIBUTES, initValue, dbMaxSemValue, W32_STRING(name));
00200         <span class="keywordflow">return</span> s != NULL; 
00201     }
00202     <span class="keywordtype">void</span> close() {
00203         CloseHandle(s);
00204     }
00205     <span class="keywordtype">void</span> erase() { 
00206         close();
00207     }
00208     dbSemaphore() { 
00209         s = NULL;
00210     }
00211 };
00212 
00213 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbEvent { 
00214   <span class="keyword">protected</span>:
00215     HANDLE e;
00216   <span class="keyword">public</span>:
00217     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec = INFINITE) { 
00218         <span class="keywordtype">int</span> rc = WaitForSingleObject(e, msec);
00219         assert(rc == WAIT_OBJECT_0 || rc == WAIT_TIMEOUT);
00220         <span class="keywordflow">return</span> rc == WAIT_OBJECT_0;
00221     }
00222     <span class="keywordtype">void</span> signal() {
00223         SetEvent(e);
00224     }
00225     <span class="keywordtype">void</span> reset() {
00226         ResetEvent(e);
00227     }
00228     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">bool</span> signaled = <span class="keyword">false</span>) {
00229         e = CreateEvent(FASTDB_SECURITY_ATTRIBUTES, <span class="keyword">true</span>, signaled, W32_STRING(name));
00230         <span class="keywordflow">return</span> e != NULL; 
00231     }
00232     <span class="keywordtype">void</span> close() {
00233         CloseHandle(e);
00234     }
00235     <span class="keywordtype">void</span> erase() { 
00236         close();
00237     }
00238     dbEvent() { 
00239         e = NULL;
00240     }
00241 };
00242 
00243 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbLocalSemaphore : <span class="keyword">public</span> dbSemaphore { 
00244   <span class="keyword">public</span>:
00245     <span class="keywordtype">bool</span> wait(dbMutex&amp; mutex, time_t timeoutMsec) { 
00246         mutex.unlock();
00247         <span class="keywordtype">int</span> rc = WaitForSingleObject(s, (DWORD)timeoutMsec);
00248         assert(rc == WAIT_OBJECT_0 || rc == WAIT_TIMEOUT);
00249         mutex.lock();
00250         <span class="keywordflow">return</span> rc == WAIT_OBJECT_0;
00251     }
00252     <span class="keywordtype">void</span> wait(dbMutex&amp; mutex) { 
00253         mutex.unlock();
00254         <span class="keywordtype">int</span> rc = WaitForSingleObject(s, INFINITE);
00255         assert(rc == WAIT_OBJECT_0);
00256         mutex.lock();
00257     }
00258     <span class="keywordtype">bool</span> open(<span class="keywordtype">unsigned</span> initValue = 0) {
00259         <span class="keywordflow">return</span> dbSemaphore::open(NULL, initValue);
00260     }
00261 };
00262 
00263 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbLocalEvent : <span class="keyword">public</span> dbEvent { 
00264   <span class="keyword">public</span>:
00265     <span class="keywordtype">bool</span> wait(dbMutex&amp; mutex, time_t timeoutMsec) { 
00266         mutex.unlock();
00267         <span class="keywordtype">int</span> rc = WaitForSingleObject(e, (DWORD)timeoutMsec);
00268         assert(rc == WAIT_OBJECT_0 || rc == WAIT_TIMEOUT);
00269         mutex.lock();
00270         <span class="keywordflow">return</span> rc == WAIT_OBJECT_0;
00271     }
00272     <span class="keywordtype">void</span> wait(dbMutex&amp; mutex) { 
00273         mutex.unlock();
00274         <span class="keywordtype">int</span> rc = WaitForSingleObject(e, INFINITE);
00275         assert(rc == WAIT_OBJECT_0);
00276         mutex.lock();
00277     }
00278     <span class="keywordtype">bool</span> open(<span class="keywordtype">bool</span> signaled = <span class="keyword">false</span>) {
00279          <span class="keywordflow">return</span> dbEvent::open(NULL, signaled);
00280      }
00281 };
00282 
00283 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbWatchDog { 
00284   <span class="keyword">public</span>:
00285     <span class="keywordtype">bool</span> watch() { 
00286         <span class="keywordflow">return</span> WaitForSingleObject(mutex, INFINITE) == ERROR_WAIT_NO_CHILDREN;
00287     }
00288     <span class="keywordtype">void</span> close() { 
00289         CloseHandle(mutex);
00290     }
00291     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name) {
00292         mutex = CreateMutex(FASTDB_SECURITY_ATTRIBUTES, <span class="keyword">true</span>, W32_STRING(name));
00293         <span class="keywordflow">return</span> mutex != NULL;
00294     }
00295     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name) {
00296 <span class="preprocessor">#if defined(_WINCE) || defined(UNICODE)</span>
00297 <span class="preprocessor"></span>        <span class="keywordflow">return</span> create(name);
00298 <span class="preprocessor">#else</span>
00299 <span class="preprocessor"></span>        mutex = OpenMutex(MUTEX_ALL_ACCESS, <span class="keyword">false</span>, name);
00300         <span class="keywordflow">return</span> mutex != NULL;
00301 <span class="preprocessor">#endif</span>
00302 <span class="preprocessor"></span>    }
00303     HANDLE mutex;
00304 };
00305 
00306 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00307 <span class="keyword">class </span>dbThreadContext { 
00308     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
00309   <span class="keyword">public</span>:
00310     T* get() { 
00311         <span class="keywordflow">return</span> (T*)TlsGetValue(index);
00312     }
00313     <span class="keywordtype">void</span> set(T* value) { 
00314         TlsSetValue(index, value);
00315     }
00316     dbThreadContext() { 
00317         index = TlsAlloc();
00318         assert(index != TLS_OUT_OF_INDEXES);
00319     }
00320     ~dbThreadContext() { 
00321         TlsFree(index);
00322     }
00323 };
00324 
00325 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00326 <span class="keyword">class </span>dbSharedObject { 
00327     T*     ptr;
00328     HANDLE h;
00329   <span class="keyword">public</span>:
00330 
00331     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span>* name) { 
00332 <span class="preprocessor">#ifdef NO_MMAP</span>
00333 <span class="preprocessor"></span>        ptr = <span class="keyword">new</span> T();
00334 <span class="preprocessor">#else</span>
00335 <span class="preprocessor"></span>        h = CreateFileMapping(INVALID_HANDLE_VALUE,
00336                               FASTDB_SECURITY_ATTRIBUTES, PAGE_READWRITE, 0, 
00337                               <span class="keyword">sizeof</span>(T), W32_STRING(name));
00338         <span class="keywordflow">if</span> (h == NULL) { 
00339             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00340         }
00341         ptr = (T*)MapViewOfFile(h, FILE_MAP_ALL_ACCESS, 0, 0, 0);
00342         <span class="keywordflow">if</span> (ptr == NULL) { 
00343             CloseHandle(h);
00344             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00345         }
00346 <span class="preprocessor">#endif</span>
00347 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;
00348     }
00349 
00350     T* get() { <span class="keywordflow">return</span> ptr; }
00351 
00352     <span class="keywordtype">void</span> close() { 
00353 <span class="preprocessor">#ifdef NO_MMAP</span>
00354 <span class="preprocessor"></span>        <span class="keyword">delete</span>[] ptr;
00355 <span class="preprocessor">#else</span>
00356 <span class="preprocessor"></span>        UnmapViewOfFile(ptr);
00357         CloseHandle(h);
00358 <span class="preprocessor">#endif</span>
00359 <span class="preprocessor"></span>    }
00360     <span class="keywordtype">void</span> erase() { 
00361         close();
00362     }
00363     dbSharedObject() { 
00364         ptr = NULL;
00365         h = NULL;
00366     }
00367 };
00368 
00369 <span class="keyword">typedef</span> <span class="keywordtype">long</span> sharedsem_t;
00370 
00371 <span class="preprocessor">#ifdef RECOVERABLE_CRITICAL_SECTION</span>
00372 <span class="preprocessor"></span><span class="keyword">class </span>FASTDB_DLL_ENTRY dbGlobalCriticalSection { 
00373     HANDLE mutex;
00374   <span class="keyword">public</span>:
00375     <span class="keywordtype">void</span> enter() { 
00376         <span class="keywordtype">int</span> rc = WaitForSingleObject(mutex, INFINITE);
00377         assert (rc == WAIT_OBJECT_0 || rc == WAIT_ABANDONED);
00378     }
00379 
00380     <span class="keywordtype">void</span> leave() {
00381         ReleaseMutex(mutex);
00382     }
00383 
00384     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">long</span>* count) { 
00385         mutex = CreateMutex(FASTDB_SECURITY_ATTRIBUTES, <span class="keyword">false</span>, W32_STRING(name));
00386         <span class="keywordflow">return</span> mutex != NULL;
00387     }
00388 
00389     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">long</span>* count) { 
00390         mutex = OpenMutex(MUTEX_ALL_ACCESS, <span class="keyword">true</span>, W32_STRING(name));
00391         <span class="keywordflow">return</span> mutex != NULL;
00392     }
00393 
00394     <span class="keywordtype">void</span> close() { 
00395         CloseHandle(mutex);
00396     }
00397     <span class="keywordtype">void</span> erase() { 
00398         close();
00399     }
00400     dbGlobalCriticalSection() {
00401         mutex = NULL;
00402     }
00403         
00404 };
00405 <span class="preprocessor">#else</span>
00406 <span class="preprocessor"></span><span class="keyword">class </span>FASTDB_DLL_ENTRY dbGlobalCriticalSection { 
00407     HANDLE       event;
00408     sharedsem_t* count;
00409 
00410   <span class="keyword">public</span>:
00411     <span class="keywordtype">void</span> enter() { 
00412         <span class="keywordflow">if</span> (InterlockedDecrement(count) != 0) { 
00413             <span class="comment">// another process is in critical section</span>
00414             <span class="keywordtype">int</span> rc = WaitForSingleObject(event, INFINITE);
00415             assert (rc == WAIT_OBJECT_0);
00416         }
00417     }
00418 
00419     <span class="keywordtype">void</span> leave() { 
00420         <span class="keywordflow">if</span> (InterlockedIncrement(count) &lt;= 0) { 
00421             <span class="comment">// some other processes try to enter critical section</span>
00422             SetEvent(event);
00423         }
00424     }
00425 
00426     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">long</span>* count) { 
00427         this-&gt;count = count;
00428         event = OpenEvent(EVENT_ALL_ACCESS, FALSE, W32_STRING(name));
00429         <span class="keywordflow">return</span> event != NULL;
00430     }
00431     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">long</span>* count) { 
00432         this-&gt;count = count;
00433         *count = 1;
00434         event = CreateEvent(FASTDB_SECURITY_ATTRIBUTES, <span class="keyword">false</span>, <span class="keyword">false</span>, W32_STRING(name));
00435         <span class="keywordflow">return</span> event != NULL;
00436     }
00437     <span class="keywordtype">void</span> close() { 
00438         CloseHandle(event);
00439     }
00440     <span class="keywordtype">void</span> erase() { 
00441         close();
00442     }
00443     dbGlobalCriticalSection() {
00444         event = NULL;
00445     }
00446         
00447 };
00448 <span class="preprocessor">#endif</span>
00449 <span class="preprocessor"></span>
00450 END_FASTDB_NAMESPACE
00451 
00452 <span class="preprocessor">#endif //__SYNC_W32_H__</span>
</pre></div><hr><address style="align: right;"><small>Generated on Thu Feb 14 12:42:30 2008 for FastDB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
