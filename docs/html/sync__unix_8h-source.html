<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sync_unix.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>sync_unix.h</h1><div class="fragment"><pre>00001 <span class="comment">//-&lt; SYNC_UNIX.H &gt;---------------------------------------------------*--------*</span>
00002 <span class="comment">// FastDB                    Version 1.0         (c) 1999  GARRET    *     ?  *</span>
00003 <span class="comment">// (Main Memory Database Management System)                          *   /\|  *</span>
00004 <span class="comment">//                                                                   *  /  \  *</span>
00005 <span class="comment">//                          Created:     20-Nov-98    K.A. Knizhnik  * / [] \ *</span>
00006 <span class="comment">//                          Last update: 20-Dec-98    K.A. Knizhnik  * GARRET *</span>
00007 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00008 <span class="comment">// Intertask synchonization primitives for Unix platforms</span>
00009 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00010 
00011 <span class="preprocessor">#ifndef __SYNC_UNIX_H__</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define __SYNC_UNIX_H__</span>
00013 <span class="preprocessor"></span>
00014 <span class="comment">// Standard includes for all Unix platforms</span>
00015 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00016 <span class="preprocessor">#include &lt;string.h&gt;</span>
00017 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00018 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00019 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00020 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00021 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00022 
00023 <span class="preprocessor">#if !defined(USE_POSIX_SEMAPHORES) || !defined(USE_POSIX_MMAP) || !USE_POSIX_MMAP</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/ipc.h&gt;</span> 
00025 <span class="keyword">extern</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* keyFileDir; <span class="comment">// default value: "/tmp/" </span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#if defined(USE_POSIX_SEMAPHORES)</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;semaphore.h&gt;</span>  <span class="comment">// For POSIX style semaphores</span>
00030 <span class="preprocessor">#else</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/sem.h&gt;</span>    <span class="comment">// For SysV style semaphores</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#if defined(USE_POSIX_MMAP) &amp;&amp; USE_POSIX_MMAP</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/mman.h&gt;</span>   <span class="comment">// For mmap()</span>
00036 <span class="preprocessor">#else</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/shm.h&gt;</span>    
00038 <span class="preprocessor">#include &lt;sys/mman.h&gt;</span>
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
00041 BEGIN_FASTDB_NAMESPACE
00042 
00043 <span class="preprocessor">#define thread_proc</span>
00044 <span class="preprocessor"></span>
00046 <span class="comment">// If this system uses pthread based threads, then define</span>
00047 <span class="comment">//   dbMutex(), dbThread(), dbLocalEvent(), etc as pthread-based implemenations</span>
00048 
00049 <span class="preprocessor">#ifndef NO_PTHREADS</span>
00050 <span class="preprocessor"></span>
00051 <span class="comment">// Use pthread based implementation</span>
00052 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00053 
00054 <span class="keyword">class </span>dbMutex { 
00055     <span class="keyword">friend</span> <span class="keyword">class </span>dbLocalEvent;
00056     <span class="keyword">friend</span> <span class="keyword">class </span>dbLocalSemaphore;
00057     pthread_mutex_t cs;
00058     <span class="keywordtype">bool</span>            initialized;
00059   <span class="keyword">public</span>:
00060     dbMutex() {
00061 <span class="preprocessor">#ifdef NDEBUG</span>
00062 <span class="preprocessor"></span>        pthread_mutex_init(&amp;cs, NULL);
00063 <span class="preprocessor">#else</span>
00064 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = pthread_mutex_init(&amp;cs, NULL);
00065         assert(rc == 0);
00066 <span class="preprocessor">#endif</span>
00067 <span class="preprocessor"></span>        initialized = <span class="keyword">true</span>;
00068     }
00069     ~dbMutex() {
00070 <span class="preprocessor">#ifdef NDEBUG</span>
00071 <span class="preprocessor"></span>        pthread_mutex_destroy(&amp;cs);
00072 <span class="preprocessor">#else</span>
00073 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = pthread_mutex_destroy(&amp;cs);
00074         assert(rc == 0);
00075 <span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>        initialized = <span class="keyword">false</span>;
00077     }
00078     <span class="keywordtype">bool</span> isInitialized() { 
00079         <span class="keywordflow">return</span> initialized;
00080     }
00081     <span class="keywordtype">void</span> lock() {
00082         <span class="keywordflow">if</span> (initialized) { 
00083 <span class="preprocessor">#ifdef NDEBUG</span>
00084 <span class="preprocessor"></span>            pthread_mutex_lock(&amp;cs);
00085 <span class="preprocessor">#else</span>
00086 <span class="preprocessor"></span>            <span class="keywordtype">int</span> rc = pthread_mutex_lock(&amp;cs);
00087             assert(rc == 0);
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>        }
00090     }
00091     <span class="keywordtype">void</span> unlock() {
00092         <span class="keywordflow">if</span> (initialized) { 
00093 <span class="preprocessor">#ifdef NDEBUG</span>
00094 <span class="preprocessor"></span>            pthread_mutex_unlock(&amp;cs);
00095 <span class="preprocessor">#else</span>
00096 <span class="preprocessor"></span>            <span class="keywordtype">int</span> rc = pthread_mutex_unlock(&amp;cs);
00097             assert(rc == 0);
00098 <span class="preprocessor">#endif</span>
00099 <span class="preprocessor"></span>        }
00100     }
00101 };
00102 
00103 
00104 <span class="keyword">const</span> size_t dbThreadStackSize = 1024*1024;
00105 
00106 <span class="keyword">class </span>dbThread { 
00107     pthread_t thread;
00108   <span class="keyword">public</span>:
00109     <span class="keyword">typedef</span> void (thread_proc* thread_proc_t)(<span class="keywordtype">void</span>*);
00110     
00111     <span class="keyword">static</span> <span class="keywordtype">void</span> sleep(time_t sec) { 
00112         ::sleep(sec);
00113     }
00114 
00115     <span class="keywordtype">void</span> create(thread_proc_t f, <span class="keywordtype">void</span>* arg) {
00116         pthread_attr_t attr;
00117         pthread_attr_init(&amp;attr);
00118 <span class="preprocessor">#if !defined(__linux__)</span>
00119 <span class="preprocessor"></span>        pthread_attr_setstacksize(&amp;attr, dbThreadStackSize);
00120 <span class="preprocessor">#endif</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#if defined(_AIX41)</span>
00122 <span class="preprocessor"></span>        <span class="comment">// At AIX 4.1, 4.2 threads are by default created detached</span>
00123         pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_UNDETACHED);
00124 <span class="preprocessor">#endif</span>
00125 <span class="preprocessor"></span>        pthread_create(&amp;thread, &amp;attr, (<span class="keywordtype">void</span>*(*)(<span class="keywordtype">void</span>*))f, arg);
00126         pthread_attr_destroy(&amp;attr);
00127     }
00128 
00129     <span class="keywordtype">void</span> join() { 
00130         <span class="keywordtype">void</span>* result;
00131         pthread_join(thread, &amp;result);
00132     }
00133     <span class="keywordtype">void</span> detach() { 
00134         pthread_detach(thread);
00135     }
00136 
00137     <span class="keyword">enum</span> ThreadPriority { 
00138         THR_PRI_LOW, 
00139         THR_PRI_HIGH
00140     };
00141     <span class="keywordtype">void</span> setPriority(ThreadPriority pri) { 
00142 <span class="preprocessor">#if defined(PRI_OTHER_MIN) &amp;&amp; defined(PRI_OTHER_MAX)</span>
00143 <span class="preprocessor"></span>        <span class="keyword">struct </span>sched_param sp;
00144         sp.sched_priority = pri == THR_PRI_LOW ? PRI_OTHER_MIN : PRI_OTHER_MAX;
00145         pthread_setschedparam(thread, SCHED_OTHER, &amp;sp); 
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span>    }
00148 
00149     <span class="keyword">static</span> <span class="keywordtype">int</span> numberOfProcessors();
00150 };
00151 
00152 
00153 <span class="keyword">class </span>dbLocalEvent { 
00154     pthread_cond_t   cond;
00155     <span class="keywordtype">int</span>              signaled;
00156   <span class="keyword">public</span>:
00157     <span class="keywordtype">void</span> wait(dbMutex&amp; mutex) { 
00158         <span class="keywordflow">while</span> (!signaled) { 
00159             pthread_cond_wait(&amp;cond, &amp;mutex.cs);
00160         }
00161     }
00162     <span class="keywordtype">bool</span> wait(dbMutex&amp; mutex, time_t timeout) {
00163         <span class="keywordflow">if</span> (!signaled) { 
00164             <span class="keyword">struct </span>timespec abs_ts; 
00165 <span class="preprocessor">#ifdef PTHREAD_GET_EXPIRATION_NP</span>
00166 <span class="preprocessor"></span>            <span class="keyword">struct </span>timespec rel_ts; 
00167             rel_ts.tv_sec = timeout/1000; 
00168             rel_ts.tv_nsec = timeout%1000*1000000;
00169             pthread_get_expiration_np(&amp;rel_ts, &amp;abs_ts);
00170 <span class="preprocessor">#else</span>
00171 <span class="preprocessor"></span>            <span class="keyword">struct </span>timeval cur_tv;
00172             gettimeofday(&amp;cur_tv, NULL);
00173             abs_ts.tv_sec = cur_tv.tv_sec + timeout/1000; 
00174             abs_ts.tv_nsec = cur_tv.tv_usec*1000 + timeout%1000*1000000;
00175             <span class="keywordflow">if</span> (abs_ts.tv_nsec &gt; 1000000000) { 
00176                 abs_ts.tv_nsec -= 1000000000;
00177                 abs_ts.tv_sec += 1;
00178             }
00179 <span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>            <span class="keywordflow">do</span> { 
00181                 <span class="keywordtype">int</span> rc = pthread_cond_timedwait(&amp;cond, &amp;mutex.cs, &amp;abs_ts);
00182                 <span class="keywordflow">if</span> (rc != 0) {
00183                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00184                 }
00185             } <span class="keywordflow">while</span> (!signaled);
00186 
00187         }
00188         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00189     }
00190     <span class="keywordtype">void</span> signal() {
00191         signaled = <span class="keyword">true</span>;
00192         pthread_cond_broadcast(&amp;cond);
00193     }
00194     <span class="keywordtype">void</span> reset() {
00195         signaled = <span class="keyword">false</span>;
00196     }
00197     <span class="keywordtype">void</span> open(<span class="keywordtype">bool</span> initValue = <span class="keyword">false</span>) { 
00198         signaled = initValue;
00199         pthread_cond_init(&amp;cond, NULL);
00200     }
00201     <span class="keywordtype">void</span> close() {
00202         pthread_cond_destroy(&amp;cond);
00203     }
00204 };
00205 
00206 <span class="keyword">class </span>dbLocalSemaphore { 
00207     pthread_cond_t   cond;
00208     <span class="keywordtype">int</span>              count;
00209   <span class="keyword">public</span>:
00210     <span class="keywordtype">void</span> wait(dbMutex&amp; mutex) { 
00211         <span class="keywordflow">while</span> (count == 0) { 
00212             pthread_cond_wait(&amp;cond, &amp;mutex.cs);
00213         }
00214         count -= 1;
00215     }
00216     <span class="keywordtype">bool</span> wait(dbMutex&amp; mutex, time_t timeout) {
00217         <span class="keywordflow">if</span> (count == 0) { 
00218             <span class="keyword">struct </span>timespec abs_ts; 
00219 <span class="preprocessor">#ifdef PTHREAD_GET_EXPIRATION_NP</span>
00220 <span class="preprocessor"></span>            <span class="keyword">struct </span>timespec rel_ts; 
00221             rel_ts.tv_sec = timeout/1000; 
00222             rel_ts.tv_nsec = timeout%1000*1000000;
00223             pthread_get_expiration_np(&amp;rel_ts, &amp;abs_ts);
00224 <span class="preprocessor">#else</span>
00225 <span class="preprocessor"></span>            <span class="keyword">struct </span>timeval cur_tv;
00226             gettimeofday(&amp;cur_tv, NULL);
00227             abs_ts.tv_sec = cur_tv.tv_sec + timeout/1000; 
00228             abs_ts.tv_nsec = cur_tv.tv_usec*1000 + timeout%1000*1000000;
00229             <span class="keywordflow">if</span> (abs_ts.tv_nsec &gt; 1000000000) { 
00230                 abs_ts.tv_nsec -= 1000000000;
00231                 abs_ts.tv_sec += 1;
00232             }
00233 <span class="preprocessor">#endif</span>
00234 <span class="preprocessor"></span>            <span class="keywordflow">do</span> { 
00235                 <span class="keywordtype">int</span> rc = pthread_cond_timedwait(&amp;cond, &amp;mutex.cs, &amp;abs_ts);
00236                 <span class="keywordflow">if</span> (rc != 0) { 
00237                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00238                 }
00239             } <span class="keywordflow">while</span> (count == 0);
00240         }
00241         count -= 1;
00242         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00243     }
00244     <span class="keywordtype">void</span> signal(<span class="keywordtype">unsigned</span> inc = 1) {
00245         count += inc;
00246         <span class="keywordflow">if</span> (inc &gt; 1) { 
00247             pthread_cond_broadcast(&amp;cond);
00248         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inc == 1) { 
00249             pthread_cond_signal(&amp;cond);
00250         }
00251     }
00252     <span class="keywordtype">void</span> open(<span class="keywordtype">unsigned</span> initValue = 0) { 
00253         pthread_cond_init(&amp;cond, NULL);
00254         count = initValue;
00255     }
00256     <span class="keywordtype">void</span> close() {
00257         pthread_cond_destroy(&amp;cond);
00258     }
00259 };
00260 
00261 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
00262 <span class="keyword">class </span>dbThreadContext { 
00263     pthread_key_t key;
00264   <span class="keyword">public</span>:
00265     T* get() { 
00266         <span class="keywordflow">return</span> (T*)pthread_getspecific(key);
00267     }
00268     <span class="keywordtype">void</span> set(T* value) { 
00269         pthread_setspecific(key, value);
00270     }
00271     dbThreadContext() { 
00272         pthread_key_create(&amp;key, NULL);
00273     }
00274     ~dbThreadContext() { 
00275         pthread_key_delete(key);
00276     }
00277 };
00278 
00279 <span class="keyword">class </span>dbProcessId { 
00280     <span class="keywordtype">int</span>       pid;
00281     pthread_t tid;
00282   <span class="keyword">public</span>:
00283     <span class="keywordtype">bool</span> operator != (dbProcessId <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{ 
00284         <span class="keywordflow">return</span> pid != other.pid || tid != other.tid;
00285     }
00286 
00287     <span class="keywordtype">void</span> clear() { 
00288         pid = 0;
00289         tid = 0;
00290     }
00291 
00292     <span class="keyword">static</span> dbProcessId getCurrent() {
00293         dbProcessId curr;
00294         curr.pid = getpid();
00295         curr.tid = pthread_self();
00296         <span class="keywordflow">return</span> curr;
00297     }
00298 };
00299 
00300 <span class="preprocessor">#else // NO_PTHREAD</span>
00301 <span class="preprocessor"></span>
00302 <span class="comment">// Non pthread based threads, mutexes, etc.</span>
00303 <span class="comment">// Maps to skeleton  functions, this implementation isn't using threads.</span>
00304 
00305 <span class="keyword">class </span>dbMutex {
00306     <span class="keywordtype">bool</span> initialized;
00307 
00308    <span class="keyword">public</span>:
00309     dbMutex() {
00310         initialized = <span class="keyword">true</span>;
00311     }
00312 
00313     ~dbMutex() { 
00314         initialized = <span class="keyword">false</span>;
00315     }
00316 
00317     <span class="keywordtype">bool</span> isInitialized() { 
00318         <span class="keywordflow">return</span> initialized;
00319     }
00320 
00321     <span class="keywordtype">void</span> lock() {}
00322     <span class="keywordtype">void</span> unlock() {}
00323 };
00324 
00325 <span class="keyword">class </span>dbThread { 
00326   <span class="keyword">public</span>:
00327     <span class="keyword">typedef</span> void (thread_proc* thread_proc_t)(<span class="keywordtype">void</span>*);
00328     <span class="keywordtype">void</span> create(thread_proc_t f, <span class="keywordtype">void</span>* arg) { f(arg); }
00329     <span class="keywordtype">void</span> join() {}
00330     <span class="keywordtype">void</span> detach() {}
00331     <span class="keyword">enum</span> ThreadPriority { 
00332         THR_PRI_LOW, 
00333         THR_PRI_HIGH
00334     };
00335     <span class="keywordtype">void</span> setPriority(ThreadPriority pri) { }
00336     <span class="keyword">static</span> <span class="keywordtype">int</span> numberOfProcessors() { <span class="keywordflow">return</span> 1; }
00337 };
00338 
00339 <span class="keyword">class </span>dbLocalSemaphore { 
00340     <span class="keywordtype">int</span> count;
00341   <span class="keyword">public</span>:
00342     <span class="keywordtype">void</span> wait(dbMutex&amp;) { 
00343         assert (count &gt; 0);
00344         count -= 1;
00345     }
00346     <span class="keywordtype">void</span> signal(<span class="keywordtype">unsigned</span> inc = 1) {
00347         count += inc;
00348     }
00349     <span class="keywordtype">void</span> open(<span class="keywordtype">unsigned</span> initValue = 0) {
00350         count = initValue;
00351     }
00352     <span class="keywordtype">void</span> close() {}
00353 };
00354 
00355 <span class="keyword">class </span>dbLocalEvent { 
00356     <span class="keywordtype">bool</span> signaled;
00357   <span class="keyword">public</span>:
00358     <span class="keywordtype">void</span> wait(dbMutex&amp;) { 
00359         assert(signaled);
00360     }
00361     <span class="keywordtype">bool</span> wait(dbMutex&amp; mutex, time_t timeout) {
00362         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00363     }
00364     <span class="keywordtype">void</span> signal() {
00365         signaled = <span class="keyword">true</span>;
00366     }
00367     <span class="keywordtype">void</span> reset() {
00368         signaled = <span class="keyword">false</span>;
00369     }
00370     <span class="keywordtype">void</span> open(<span class="keywordtype">bool</span> initValue = <span class="keyword">false</span>) {
00371         signaled = initValue;
00372     }
00373     <span class="keywordtype">void</span> close() {}
00374 };
00375 
00376 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00377 <span class="keyword">class </span>dbThreadContext { 
00378     T* value;
00379   <span class="keyword">public</span>:
00380     T* get() { 
00381         <span class="keywordflow">return</span> value;
00382     }
00383     <span class="keywordtype">void</span> set(T* value) { 
00384         this-&gt;value = value;
00385     }
00386     dbThreadContext() { value = NULL; }
00387 };
00388 
00389 
00390 <span class="keyword">class </span>dbProcessId { 
00391     <span class="keywordtype">int</span>       pid;
00392   <span class="keyword">public</span>:
00393     <span class="keywordtype">bool</span> operator != (dbProcessId <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{ 
00394         <span class="keywordflow">return</span> pid != other.pid;
00395     }
00396     
00397     <span class="keywordtype">void</span> clear() { 
00398         pid = 0;
00399     }
00400 
00401     <span class="keyword">static</span> dbProcessId getCurrent() {
00402         dbProcessId curr;
00403         curr.pid = getpid();
00404         <span class="keywordflow">return</span> curr;
00405     }
00406 };
00407 
00408 <span class="preprocessor">#endif // NO_PTHREAD</span>
00409 <span class="preprocessor"></span>
00410 
00411 <span class="preprocessor">#define INFINITE (~0U)</span>
00412 <span class="preprocessor"></span>
00413 
00414 <span class="preprocessor">#ifdef USE_POSIX_SEMAPHORES</span>
00415 <span class="preprocessor"></span>
00416 <span class="comment">// Initialization Mutex using Posix based semaphores</span>
00417 <span class="keyword">class </span>dbInitializationMutex { 
00418     sem_t* sem;
00419     <span class="keywordtype">char</span>*  name;
00420   <span class="keyword">public</span>: 
00421     <span class="keyword">enum</span> initializationStatus { 
00422         InitializationError, 
00423         AlreadyInitialized,
00424         NotYetInitialized
00425     };
00426     initializationStatus initialize(<span class="keywordtype">char</span> <span class="keyword">const</span>* name) { 
00427         initializationStatus status;
00428         this-&gt;name = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(name)+2];
00429         <span class="keywordflow">if</span> (*name != <span class="charliteral">'/'</span>) { 
00430             strcpy(this-&gt;name+1, name);
00431             *this-&gt;name = <span class="charliteral">'/'</span>;
00432         } <span class="keywordflow">else</span> { 
00433             strcpy(this-&gt;name, name);
00434         }
00435         <span class="keywordflow">while</span> (true) {
00436             sem = sem_open(this-&gt;name, 0);
00437             <span class="keywordflow">if</span> (sem == SEM_FAILED) { 
00438                 <span class="keywordflow">if</span> (errno == ENOENT) {
00439                     sem = sem_open(this-&gt;name, O_CREAT|O_EXCL, 0777, 0);
00440                     <span class="keywordflow">if</span> (sem != SEM_FAILED) { 
00441                         status = NotYetInitialized;
00442                         <span class="keywordflow">break</span>;
00443                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (errno != EEXIST) { 
00444                         status = InitializationError;
00445                         <span class="keywordflow">break</span>;
00446                     }
00447                 } <span class="keywordflow">else</span> { 
00448                     status = InitializationError;
00449                     <span class="keywordflow">break</span>;
00450                 }
00451             } <span class="keywordflow">else</span> { 
00452                 status = (sem_wait(sem) == 0 &amp;&amp; sem_post(sem) == 0) 
00453                     ? AlreadyInitialized : InitializationError;
00454                 <span class="keywordflow">break</span>;
00455             }
00456         }
00457         <span class="keywordflow">return</span> status;
00458     }
00459 
00460     <span class="keywordtype">void</span> done() { 
00461         sem_post(sem);
00462     }
00463     <span class="keywordtype">bool</span> close() {
00464         sem_close(sem);
00465         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00466     }
00467     <span class="keywordtype">void</span> erase() {
00468         sem_unlink(name);
00469         <span class="keyword">delete</span>[] name;
00470     }
00471 };
00472 
00473 <span class="keyword">class </span>dbSemaphore { 
00474   <span class="keyword">protected</span>:
00475     sem_t* sem;
00476     <span class="keywordtype">char</span>*  name;
00477   <span class="keyword">public</span>:
00478     <span class="keywordtype">void</span> wait() { 
00479 <span class="preprocessor">#ifdef NDEBUG</span>
00480 <span class="preprocessor"></span>        sem_wait(sem);
00481 <span class="preprocessor">#else</span>
00482 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = sem_wait(sem);
00483         assert(rc == 0);
00484 <span class="preprocessor">#endif</span>
00485 <span class="preprocessor"></span>    }
00486 
00487     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec) { 
00488 <span class="preprocessor">#ifdef POSIX_1003_1d</span>
00489 <span class="preprocessor"></span>        <span class="keyword">struct </span>timespec abs_ts;
00490         <span class="keyword">struct </span>timeval  cur_tv;
00491         clock_gettime(CLOCK_REALTIME, &amp;cur_tv);
00492         abs_ts.tv_sec = cur_tv.tv_sec + (msec + cur_tv.tv_usec / 1000) / 1000000; 
00493         abs_ts.tv_nsec = (msec + cur_tv.tv_usec / 1000) % 1000000 * 1000;
00494         <span class="keywordtype">int</span> rc = sem_timedwait(sem, &amp;abs_ts);
00495         <span class="keywordflow">if</span> (rc &lt; 0) { 
00496             assert(errno == ETIMEDOUT);
00497             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00498         }
00499         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00500 <span class="preprocessor">#else </span>
00501 <span class="preprocessor"></span><span class="preprocessor">#ifdef NDEBUG</span>
00502 <span class="preprocessor"></span>        sem_wait(sem);
00503 <span class="preprocessor">#else</span>
00504 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = sem_wait(sem);
00505         assert(rc == 0);
00506 <span class="preprocessor">#endif</span>
00507 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;
00508 <span class="preprocessor">#endif  </span>
00509 <span class="preprocessor"></span>    }
00510 
00511     <span class="keywordtype">void</span> signal(<span class="keywordtype">unsigned</span> inc = 1) {
00512         <span class="keywordflow">while</span> (inc-- &gt; 0) { 
00513             sem_post(sem);
00514         }
00515     }
00516     <span class="keywordtype">void</span> reset() { 
00517         <span class="keywordflow">while</span> (sem_trywait(sem) == 0);
00518     }    
00519     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">unsigned</span> initValue = 0) {
00520         this-&gt;name = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(name)+2];
00521         <span class="keywordflow">if</span> (*name != <span class="charliteral">'/'</span>) { 
00522             strcpy(this-&gt;name+1, name);
00523             *this-&gt;name = <span class="charliteral">'/'</span>;
00524         } <span class="keywordflow">else</span> { 
00525             strcpy(this-&gt;name, name);
00526         }
00527         sem = sem_open(this-&gt;name, O_CREAT, 0777, initValue);
00528         <span class="keywordflow">return</span> sem != NULL; 
00529     }
00530     <span class="keywordtype">void</span> close() {
00531         <span class="keywordflow">if</span> (sem != NULL) { 
00532             sem_close(sem);
00533             sem = NULL;
00534         }
00535     }
00536     <span class="keywordtype">void</span> erase() { 
00537         close();
00538         sem_unlink(name);
00539         <span class="keyword">delete</span>[] name;
00540     }
00541 };
00542 
00543 <span class="keyword">class </span>dbEvent : <span class="keyword">public</span> dbSemaphore { 
00544   <span class="keyword">public</span>:
00545     <span class="keywordtype">void</span> wait() { 
00546         dbSemaphore::wait();
00547         sem_post(sem);
00548     }
00549     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec) { 
00550         <span class="keywordflow">if</span> (dbSemaphore::wait(msec)) { 
00551             sem_post(sem);
00552             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00553         }
00554         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00555     }
00556     <span class="keywordtype">void</span> signal() {
00557         <span class="keywordflow">while</span> (sem_trywait(sem) == 0);
00558         sem_post(sem);
00559     }
00560     <span class="keywordtype">void</span> reset() {
00561         <span class="keywordflow">while</span> (sem_trywait(sem) == 0);
00562     }
00563     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">bool</span> signaled = <span class="keyword">false</span>) {
00564         <span class="keywordflow">return</span> dbSemaphore::open(name, (<span class="keywordtype">int</span>)signaled);
00565     }
00566 };
00567 <span class="preprocessor">#else // USE_POSIX_SEMAPHORES</span>
00568 <span class="preprocessor"></span>
00569 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbWatchDog { 
00570     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">int</span> flags);
00571   <span class="keyword">public</span>:
00572     <span class="keywordtype">bool</span> watch();
00573     <span class="keywordtype">void</span> close(); 
00574     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
00575     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
00576     <span class="keywordtype">int</span> id;
00577 };
00578 
00579 <span class="comment">// Define local implemenation of InitializationMutex in sync.cpp</span>
00580 <span class="keyword">class </span>dbInitializationMutex { 
00581     <span class="keywordtype">int</span> semid;
00582   <span class="keyword">public</span>: 
00583     <span class="keyword">enum</span> initializationStatus { 
00584         InitializationError, 
00585         AlreadyInitialized,
00586         NotYetInitialized
00587     };
00588     initializationStatus initialize(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
00589     <span class="keywordtype">void</span> done(); 
00590     <span class="keywordtype">bool</span> close();
00591     <span class="keywordtype">void</span> erase();
00592 };
00593 
00594 
00595 <span class="keyword">class </span>dbSemaphore { 
00596     <span class="keywordtype">int</span> s;
00597   <span class="keyword">public</span>:
00598     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec = INFINITE);
00599     <span class="keywordtype">void</span> signal(<span class="keywordtype">unsigned</span> inc = 1);
00600     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">unsigned</span> initValue = 0);
00601     <span class="keywordtype">void</span> reset();
00602     <span class="keywordtype">void</span> close();
00603     <span class="keywordtype">void</span> erase();
00604 };
00605 
00606 <span class="keyword">class </span>dbEvent { 
00607     <span class="keywordtype">int</span> e;
00608   <span class="keyword">public</span>:
00609     <span class="keywordtype">bool</span> wait(<span class="keywordtype">unsigned</span> msec = INFINITE);
00610     <span class="keywordtype">void</span> signal();
00611     <span class="keywordtype">void</span> reset();
00612     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, <span class="keywordtype">bool</span> signaled = <span class="keyword">false</span>);
00613     <span class="keywordtype">void</span> close();
00614     <span class="keywordtype">void</span> erase();
00615 };
00616 <span class="preprocessor">#endif // USE_POSIX_SEMAPHORES</span>
00617 <span class="preprocessor"></span>
00618 
00619 <span class="comment">// Define dbSharedObject and dbSharedMemory</span>
00620 <span class="preprocessor">#if defined(USE_POSIX_MMAP) &amp;&amp; USE_POSIX_MMAP</span>
00621 <span class="preprocessor"></span>
00622 <span class="comment">// For POSIX dbSharedObject, we use mmap()</span>
00623 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00624 <span class="keyword">class </span>dbSharedObject { 
00625     <span class="keywordtype">char</span>* name;
00626     T*  ptr;
00627     <span class="keywordtype">int</span> fd;
00628   <span class="keyword">public</span>:
00629 
00630     dbSharedObject() { 
00631         name = NULL;
00632         ptr = NULL;
00633         fd = -1;
00634     }
00635 
00636     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span>* fileName) { 
00637         <span class="keyword">delete</span>[] name;
00638         name = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(fileName) + 1];
00639         strcpy(name, fileName);
00640         fd = ::open(fileName, O_RDWR|O_CREAT, 0777);
00641         <span class="keywordflow">if</span> (fd &lt; 0) { 
00642             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00643         }
00644         <span class="keywordflow">if</span> (ftruncate(fd, <span class="keyword">sizeof</span>(T)) &lt; 0) {
00645             ::close(fd);
00646             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00647         }
00648         ptr = (T*)mmap(NULL,
00649                        DOALIGN(<span class="keyword">sizeof</span>(T), 4096),
00650                        PROT_READ|PROT_WRITE,
00651                        MAP_SHARED,
00652                        fd,
00653                        0);
00654         <span class="keywordflow">if</span> (ptr == MAP_FAILED) { 
00655             ptr = NULL;
00656             ::close(fd);
00657             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00658         }
00659         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00660     }
00661 
00662     T* get() { <span class="keywordflow">return</span> ptr; }
00663 
00664     <span class="keywordtype">void</span> close() { 
00665         <span class="keywordflow">if</span> (ptr != NULL) { 
00666             munmap((<span class="keywordtype">char</span>*)ptr, DOALIGN(<span class="keyword">sizeof</span>(T), 4096));
00667         }
00668         <span class="keywordflow">if</span> (fd &gt; 0) { 
00669             ::close(fd);
00670         }
00671     }
00672     <span class="keywordtype">void</span> erase() {
00673         close();
00674         unlink(name);   
00675     }  
00676 
00677     ~dbSharedObject() { 
00678         <span class="keyword">delete</span>[] name;
00679     }
00680 };
00681 
00682 <span class="preprocessor">#else // USE_POSIX_MMAP</span>
00683 <span class="preprocessor"></span>
00684 <span class="comment">// Non POSIX, internal implementations of SharedMemory and SharedObject</span>
00685 <span class="keyword">extern</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* keyFileDir; <span class="comment">// default value: "/tmp/" </span>
00686 <span class="keyword">class </span>dbSharedMemory { 
00687   <span class="keyword">protected</span>:
00688     <span class="keywordtype">char</span>*  ptr;
00689     <span class="keywordtype">int</span>    shm;
00690 
00691   <span class="keyword">public</span>:
00692     <span class="keywordtype">bool</span>  open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, size_t size); 
00693     <span class="keywordtype">void</span>  close();
00694     <span class="keywordtype">void</span>  erase(); 
00695     <span class="keywordtype">char</span>* get_base() { 
00696         <span class="keywordflow">return</span> ptr;
00697     }
00698 };
00699 
00700 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00701 <span class="keyword">class </span>dbSharedObject : <span class="keyword">public</span> dbSharedMemory { 
00702   <span class="keyword">public</span>:
00703     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span>* name) { 
00704         <span class="keywordflow">return</span> dbSharedMemory::open(name, <span class="keyword">sizeof</span>(T));
00705     }
00706     T* get() { <span class="keywordflow">return</span> (T*)ptr; }
00707 };
00708 
00709 <span class="preprocessor">#endif</span>
00710 <span class="preprocessor"></span>
00712 <span class="comment">// Define dBGlobalCriticalSection for various platforms</span>
00713 
00714 <span class="comment">// QNX uses a pthread based mutex for its implementation</span>
00715 <span class="comment">//     Use only if pthread support is also enabled, else we'll use the default case</span>
00716 <span class="preprocessor">#if defined(__QNX__) &amp;&amp; !defined(NO_PTHREADS)</span>
00717 <span class="preprocessor"></span><span class="keyword">typedef</span> pthread_mutex_t sharedsem_t;
00718 
00719 <span class="keyword">class </span>dbGlobalCriticalSection { 
00720     pthread_mutexattr_t attr;
00721     sharedsem_t* sem;
00722   <span class="keyword">public</span>:
00723     <span class="keywordtype">void</span> enter() {
00724 <span class="preprocessor">#ifdef NDEBUG</span>
00725 <span class="preprocessor"></span>        pthread_mutex_lock(sem);
00726 <span class="preprocessor">#else</span>
00727 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = pthread_mutex_lock(sem);
00728         assert(rc == 0);
00729 <span class="preprocessor">#endif</span>
00730 <span class="preprocessor"></span>    }
00731     <span class="keywordtype">void</span> leave() { 
00732 <span class="preprocessor">#ifdef NDEBUG</span>
00733 <span class="preprocessor"></span>        pthread_mutex_unlock(sem);
00734 <span class="preprocessor">#else</span>
00735 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = pthread_mutex_unlock(sem);
00736         assert(rc == 0);
00737 <span class="preprocessor">#endif</span>
00738 <span class="preprocessor"></span>    }
00739     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00740         sem = shr;
00741         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00742     }
00743     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00744         sem = shr;
00745         pthread_mutexattr_init(&amp;attr);
00746         pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED);
00747         pthread_mutexattr_setrecursive(&amp;attr, PTHREAD_RECURSIVE_ENABLE);
00748         pthread_mutex_init(sem, &amp;attr);
00749         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00750     }
00751     <span class="keywordtype">void</span> close() {}
00752     <span class="keywordtype">void</span> erase() {
00753         pthread_mutex_destroy(sem);
00754     }
00755 };
00756 
00757 
00758 <span class="preprocessor">#elif defined(__osf__) &amp;&amp; !defined(RECOVERABLE_CRITICAL_SECTION)</span>
00759 <span class="preprocessor"></span><span class="comment">// OSF uses "shared memory semaphores", located within a region mapped with mmap().</span>
00760 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00761 <span class="keyword">typedef</span> msemaphore sharedsem_t;
00762 
00763 <span class="keyword">class </span>dbGlobalCriticalSection { 
00764     sharedsem_t* sem;
00765   <span class="keyword">public</span>:
00766     <span class="keywordtype">void</span> enter() { 
00767         <span class="keywordtype">int</span> rc;
00768         <span class="keywordflow">while</span> ((rc = msem_lock(sem, 0)) &lt; 0 &amp;&amp; errno == EINTR);
00769         assert(rc == 0);
00770     }
00771     <span class="keywordtype">void</span> leave() { 
00772         <span class="keywordtype">int</span> rc = msem_unlock(sem, 0);
00773         assert(rc == 0);        
00774     }
00775     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00776         sem = shr;
00777         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00778     }
00779     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00780         sem = shr;
00781         msem_init(shr, MSEM_UNLOCKED);
00782         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00783     }
00784     <span class="keywordtype">void</span> close() {}
00785     <span class="keywordtype">void</span> erase() {
00786         msem_remove(sem);
00787     }
00788 };
00789         
00790 
00791 <span class="preprocessor">#elif defined(__sun) &amp;&amp; !defined(RECOVERABLE_CRITICAL_SECTION)</span>
00792 <span class="preprocessor"></span><span class="comment">// Sun uses the Solaris style semaphore implemenation (sema_init(), sema_post())</span>
00793 <span class="preprocessor">#include &lt;synch.h&gt;</span>
00794 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00795 <span class="keyword">typedef</span> sema_t sharedsem_t;
00796 
00797 <span class="keyword">class </span>dbGlobalCriticalSection { 
00798     sharedsem_t* sem;
00799   <span class="keyword">public</span>:
00800     <span class="keywordtype">void</span> enter() { 
00801 <span class="preprocessor">#ifdef NDEBUG</span>
00802 <span class="preprocessor"></span>        <span class="keywordflow">while</span> (sema_wait(sem) &lt; 0 &amp;&amp; errno == EINTR);
00803 <span class="preprocessor">#else</span>
00804 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc;
00805         <span class="keywordflow">while</span> ((rc = sema_wait(sem)) &lt; 0 &amp;&amp; errno == EINTR);
00806         assert(rc == 0);
00807 <span class="preprocessor">#endif</span>
00808 <span class="preprocessor"></span>    }
00809     <span class="keywordtype">void</span> leave() { 
00810 <span class="preprocessor">#ifdef NDEBUG</span>
00811 <span class="preprocessor"></span>        sema_post(sem);
00812 <span class="preprocessor">#else</span>
00813 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = sema_post(sem);
00814         assert(rc == 0);
00815 <span class="preprocessor">#endif</span>
00816 <span class="preprocessor"></span>    }
00817     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00818         sem = shr;
00819         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00820     }
00821     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>*, sharedsem_t* shr) { 
00822         sem = shr;
00823         <span class="keywordflow">return</span> sema_init(shr, 1, USYNC_PROCESS, NULL) == 0;
00824     }
00825     <span class="keywordtype">void</span> close() {}
00826     <span class="keywordtype">void</span> erase() {
00827         sema_destroy(sem);
00828     }
00829 };
00830 
00831 <span class="preprocessor">#elif defined(USE_POSIX_SEMAPHORES) &amp;&amp; !defined(RECOVERABLE_CRITICAL_SECTION)</span>
00832 <span class="preprocessor"></span><span class="comment">// Everyone else uses the POSIX style semaphores (sem_wait(), sem_post(), etc) if defined</span>
00833 <span class="keyword">typedef</span> sem_t sharedsem_t;
00834 
00835 <span class="keyword">class </span>dbGlobalCriticalSection { 
00836     sharedsem_t* sem;
00837 
00838   <span class="keyword">public</span>:
00839     <span class="keywordtype">void</span> enter() { 
00840 <span class="preprocessor">#ifdef NDEBUG</span>
00841 <span class="preprocessor"></span>        sem_wait(sem);
00842 <span class="preprocessor">#else</span>
00843 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = sem_wait(sem);
00844         assert(rc == 0);
00845 <span class="preprocessor">#endif</span>
00846 <span class="preprocessor"></span>    }
00847     <span class="keywordtype">void</span> leave() { 
00848 <span class="preprocessor">#ifdef NDEBUG</span>
00849 <span class="preprocessor"></span>        sem_post(sem);
00850 <span class="preprocessor">#else</span>
00851 <span class="preprocessor"></span>        <span class="keywordtype">int</span> rc = sem_post(sem);
00852         assert(rc == 0);
00853 <span class="preprocessor">#endif</span>
00854 <span class="preprocessor"></span>    }
00855     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, sharedsem_t* shr) { 
00856         sem = shr;
00857         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00858     }
00859 
00860     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, sharedsem_t* shr) {   
00861         sem = shr;
00862         <span class="keywordflow">return</span> sem_init(sem, 1, 1) == 0;
00863     }
00864 
00865     <span class="keywordtype">void</span> close() {}
00866     <span class="keywordtype">void</span> erase() { 
00867         sem_destroy(sem);
00868     }
00869 };
00870 
00871 <span class="preprocessor">#else</span>
00872 <span class="preprocessor"></span>
00873 <span class="preprocessor">#define USE_LOCAL_CS_IMPL</span>
00874 <span class="preprocessor"></span>
00875 <span class="preprocessor">#define GLOBAL_CS_DEBUG 1</span>
00876 <span class="preprocessor"></span>
00877 <span class="comment">// Lastly, use the local implementation</span>
00878 <span class="keyword">typedef</span> <span class="keywordtype">long</span> sharedsem_t;
00879 
00880 <span class="keyword">class </span>dbGlobalCriticalSection { 
00881     <span class="keywordtype">int</span>          semid;
00882     sharedsem_t* count;
00883 <span class="preprocessor">#if GLOBAL_CS_DEBUG</span>
00884 <span class="preprocessor"></span>    pthread_t    owner;
00885 <span class="preprocessor">#endif</span>
00886 <span class="preprocessor"></span>
00887   <span class="keyword">public</span>:
00888     <span class="keywordtype">void</span> enter(); 
00889     <span class="keywordtype">void</span> leave();
00890     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, sharedsem_t* shr);
00891     <span class="keywordtype">bool</span> create(<span class="keywordtype">char</span> <span class="keyword">const</span>* name, sharedsem_t* shr);
00892     <span class="keywordtype">void</span> close() {}
00893     <span class="keywordtype">void</span> erase();
00894 };
00895 <span class="preprocessor">#endif //dbGLobalCriticalSection switch</span>
00896 <span class="preprocessor"></span>
00897 END_FASTDB_NAMESPACE
00898 
00899 <span class="preprocessor">#endif //__SYNC_UNIX_H__</span>
</pre></div><hr><address style="align: right;"><small>Generated on Thu Feb 14 12:42:30 2008 for FastDB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
