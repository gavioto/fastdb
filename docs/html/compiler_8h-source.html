<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>compiler.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>compiler.h</h1><div class="fragment"><pre>00001 <span class="comment">//-&lt; COMPILE.H &gt;-----------------------------------------------------*--------*</span>
00002 <span class="comment">// FastDB                    Version 1.0         (c) 1999  GARRET    *     ?  *</span>
00003 <span class="comment">// (Main Memory Database Management System)                          *   /\|  *</span>
00004 <span class="comment">//                                                                   *  /  \  *</span>
00005 <span class="comment">//                          Created:     20-Nov-98    K.A. Knizhnik  * / [] \ *</span>
00006 <span class="comment">//                          Last update: 17-Jan-99    K.A. Knizhnik  * GARRET *</span>
00007 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00008 <span class="comment">// Conditional expresion compiler</span>
00009 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00010 
00011 <span class="preprocessor">#ifndef __COMPILER_H__</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define __COMPILER_H__</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
00015 <span class="preprocessor">#ifdef USE_REGEX</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;regex.h&gt;</span>
00017 <span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 BEGIN_FASTDB_NAMESPACE
00020 
00021 <span class="preprocessor">#if defined(__osf__) || defined(__FreeBSD__)</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define longjmp(b,s) _longjmp(b,s) // do not restore signal context</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define setjmp(b)  _setjmp(b)</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="keyword">enum</span> dbvmCodes { 
00027 <span class="preprocessor">#define DBVM(cop, type, n_operands, commutative) cop,</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#include "compiler.d"</span>
00029 dbvmLastCode
00030 };
00031 
00032 <span class="preprocessor">#define IS_CONSTANT(c) \</span>
00033 <span class="preprocessor">    (unsigned(c) - dbvmLoadVarBool &lt;= (unsigned)dbvmLoadRectangleConstant - dbvmLoadVarBool)</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">enum</span> nodeType { 
00036     tpInteger,
00037     tpBoolean,
00038     tpReal,
00039     tpString,
00040     tpReference,
00041     tpRectangle,
00042     tpArray,
00043     tpRawBinary, 
00044     tpFreeVar,  <span class="comment">// index of EXISTS clause </span>
00045     tpList,     <span class="comment">// list of expressions</span>
00046     tpVoid
00047 };
00048 
00049 <span class="keyword">enum</span> tokens { 
00050     tkn_ident,
00051     tkn_lpar,
00052     tkn_rpar,
00053     tkn_lbr,
00054     tkn_rbr,
00055     tkn_dot,
00056     tkn_comma,
00057     tkn_power,
00058     tkn_iconst,
00059     tkn_sconst,
00060     tkn_fconst,
00061     tkn_add,
00062     tkn_sub,
00063     tkn_mul,
00064     tkn_div,
00065     tkn_and,
00066     tkn_or,
00067     tkn_not,
00068     tkn_null,
00069     tkn_neg,
00070     tkn_eq,
00071     tkn_ne,
00072     tkn_gt,
00073     tkn_ge,
00074     tkn_lt,
00075     tkn_le,
00076     tkn_between,
00077     tkn_escape,
00078     tkn_exists,
00079     tkn_like,
00080     tkn_limit,
00081     tkn_in,
00082     tkn_length,
00083     tkn_lower,
00084     tkn_upper,
00085     tkn_abs,
00086     tkn_area,
00087     tkn_is,
00088     tkn_integer,
00089     tkn_real,
00090     tkn_string,
00091     tkn_first,
00092     tkn_last,
00093     tkn_current,
00094     tkn_var,
00095     tkn_col,
00096     tkn_true,
00097     tkn_false,
00098     tkn_where, 
00099     tkn_follow,
00100     tkn_start,
00101     tkn_from,
00102     tkn_order,
00103     tkn_overlaps,
00104     tkn_by,
00105     tkn_asc,
00106     tkn_desc, 
00107     tkn_eof,
00108     tkn_insert, 
00109     tkn_into, 
00110     tkn_select, 
00111     tkn_table,
00112     tkn_error,
00113     tkn_all, 
00114     tkn_match,
00115     tkn_last_token
00116 };    
00117 
00118 <span class="keyword">struct </span>dbStrLiteral { 
00119     <span class="keywordtype">char</span>* str;
00120     <span class="keywordtype">int</span>   len;
00121 };
00122 
00123 
00124 <span class="keyword">class </span><a class="code" href="classdbUserFunction.html">dbUserFunction</a>;
00125 <span class="keyword">class </span>dbExprNodeSegment;
00126 
00127 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbExprNodeAllocator { 
00128   <span class="keyword">private</span>:
00129     <span class="keyword">friend</span> <span class="keyword">class </span>dbExprNodeSegment;
00130     dbExprNode*        freeNodeList;
00131     dbExprNodeSegment* segmentList;
00132     dbMutex            mutex;
00133     
00134   <span class="keyword">public</span>:  
00135     dbMutex&amp;    getMutex() {
00136         <span class="keywordflow">return</span> mutex;
00137     }
00138     dbExprNode* allocate();
00139     <span class="keywordtype">void</span>        deallocate(dbExprNode* node);
00140     <span class="keywordtype">void</span>        reset();
00141 
00142     ~dbExprNodeAllocator();
00143     <span class="keyword">static</span> dbExprNodeAllocator instance;
00144 };
00145 
00146 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbExprNode { 
00147     <span class="keyword">friend</span> <span class="keyword">class </span>dbExprNodeSegment;
00148   <span class="keyword">public</span>:
00149     nat1 cop;
00150     nat1 type;
00151     nat2 offs;
00152 
00153     <span class="keyword">static</span> <span class="keyword">const</span> nat1  nodeTypes[];
00154     <span class="keyword">static</span> <span class="keyword">const</span> nat1  nodeOperands[];
00155     <span class="keyword">static</span> <span class="keyword">const</span> nat1  commutativeOperator[];
00156 
00157     <span class="keyword">struct </span>ref_operands { 
00158         dbExprNode*         base;  <span class="comment">// the same as operand[0]</span>
00159         <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>*  field;
00160     };
00161 
00162     <span class="keyword">struct </span>func_operands { 
00163         dbExprNode*         arg[3]; 
00164         <span class="keywordtype">void</span>*               fptr;
00165     };
00166 
00167 <span class="preprocessor">#ifdef USE_REGEX</span>
00168 <span class="preprocessor"></span>    <span class="keyword">struct </span>regex_operands { 
00169         dbExprNode*         opd;  
00170         regex_t             re;
00171     };
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span>
00174     <span class="keyword">union </span>{ 
00175         dbExprNode*    operand[3];
00176         dbExprNode*    next;
00177         oid_t          oid;
00178         db_int8        ivalue;
00179         real8          fvalue;
00180         <a class="code" href="classrectangle.html">rectangle</a>      rvalue;
00181         dbStrLiteral   svalue;
00182         <span class="keywordtype">void</span> <span class="keyword">const</span>*    var;
00183         ref_operands   ref;
00184         func_operands  func;
00185 <span class="preprocessor">#ifdef USE_REGEX</span>
00186 <span class="preprocessor"></span>        regex_operands regex;
00187 <span class="preprocessor">#endif</span>
00188 <span class="preprocessor"></span>    };
00189 
00190     dbExprNode(dbExprNode* node);
00191 
00192     dbExprNode(<span class="keywordtype">int</span> cop, dbExprNode* left = NULL, dbExprNode* right = NULL, 
00193                dbExprNode* right2 = NULL)
00194     {
00195         this-&gt;cop = cop;
00196         type = nodeTypes[cop];
00197         operand[0] = left;
00198         operand[1] = right;
00199         operand[2] = right2;
00200     }
00201     dbExprNode(<span class="keywordtype">int</span> cop, dbExprNode* expr1, dbExprNode* expr2, <span class="keywordtype">int</span> offs) { 
00202         this-&gt;cop = cop;
00203         this-&gt;offs = (nat2)offs;
00204         type = nodeTypes[cop];
00205         operand[0] = expr1;
00206         operand[1] = expr2;
00207     }
00208     dbExprNode(<span class="keywordtype">int</span> cop, dbExprNode* expr, <span class="keywordtype">int</span> offs) { 
00209         this-&gt;cop = cop;
00210         this-&gt;offs = (nat2)offs;
00211         type = nodeTypes[cop];
00212         operand[0] = expr;
00213     }
00214     dbExprNode(<span class="keywordtype">int</span> cop, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* field, dbExprNode* base = NULL) 
00215     {
00216         this-&gt;cop = cop;
00217         this-&gt;offs = (nat2)field-&gt;<a class="code" href="classdbFieldDescriptor.html#dbFieldDescriptorm17">dbsOffs</a>;
00218         type = nodeTypes[cop];
00219         ref.field = field;
00220         ref.base = base;
00221     }
00222     dbExprNode(<span class="keywordtype">int</span> cop, db_int8 ivalue) { 
00223         this-&gt;cop = cop;
00224         this-&gt;ivalue = ivalue;
00225         type = tpInteger;
00226     }
00227     dbExprNode(<span class="keywordtype">int</span> cop, real8 fvalue) { 
00228         this-&gt;cop = cop;
00229         this-&gt;fvalue = fvalue;
00230         type = tpReal;
00231     }
00232     dbExprNode(<span class="keywordtype">int</span> cop, <a class="code" href="classrectangle.html">rectangle</a> rvalue) {
00233         this-&gt;cop = cop;
00234         this-&gt;rvalue = rvalue;
00235         type = tpRectangle;
00236     }
00237     dbExprNode(<span class="keywordtype">int</span> cop, dbStrLiteral&amp; svalue) { 
00238         this-&gt;cop = cop;
00239         this-&gt;svalue = svalue;
00240         type = tpString;
00241     }
00242     dbExprNode(<span class="keywordtype">int</span> cop, <span class="keywordtype">void</span> <span class="keyword">const</span>* var) { 
00243         this-&gt;cop = cop;
00244         this-&gt;var = var;
00245         type = nodeTypes[cop];
00246     }
00247     dbExprNode(<span class="keywordtype">int</span> cop, <span class="keywordtype">void</span>* fptr, dbExprNode* expr1, dbExprNode* expr2 = NULL, dbExprNode* expr3 = NULL) { 
00248         this-&gt;cop = cop;
00249         func.arg[0] = expr1;
00250         func.arg[1] = expr2;
00251         func.arg[2] = expr3;
00252         func.fptr = fptr;
00253         type = nodeTypes[cop];
00254     }
00255     ~dbExprNode();
00256 
00257     <span class="keywordtype">void</span>* operator new(size_t size EXTRA_DEBUG_NEW_PARAMS) { 
00258         <span class="keywordflow">return</span> dbExprNodeAllocator::instance.allocate();
00259     }
00260 
00261     <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span>* ptr EXTRA_DEBUG_NEW_PARAMS) { 
00262         dbExprNodeAllocator::instance.deallocate((dbExprNode*)ptr);
00263     }
00264 };
00265 
00266 
00267 <span class="keyword">class </span>dbExprNodeSegment { 
00268   <span class="keyword">public</span>:
00269     <span class="keyword">enum</span> { allocationQuantum = 1024};
00270     <span class="keywordtype">char</span>               buf[<span class="keyword">sizeof</span>(dbExprNode)*allocationQuantum];
00271     dbExprNodeSegment* next;
00272 };
00273 
00274 
00275 <span class="keyword">class </span>dbBinding { 
00276   <span class="keyword">public</span>:
00277     dbBinding*  next;
00278     <span class="keywordtype">char</span> <span class="keyword">const</span>* name;
00279     <span class="keywordtype">bool</span>        used;
00280     <span class="keywordtype">int</span>         index;
00281 };
00282 
00283 <span class="keyword">class </span>dbOrderByNode { 
00284   <span class="keyword">public</span>:
00285     dbOrderByNode*     next;
00286     <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* field;
00287     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table;
00288     dbExprNode*        expr;
00289     <span class="keywordtype">bool</span>               ascent;  <span class="comment">// true for ascent order, false for descent </span>
00290     
00291     ~dbOrderByNode() { 
00292         <span class="keyword">delete</span> expr;
00293     }
00294 };
00295 
00296 <span class="keyword">class </span>dbFollowByNode { 
00297   <span class="keyword">public</span>:
00298     dbFollowByNode*    next;
00299     <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* field;
00300 };
00301 
00302 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbCompiler { 
00303     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbQuery.html">dbQuery</a>;
00304     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbQueryElement.html">dbQueryElement</a>;
00305   <span class="keyword">public</span>:
00306     <span class="keyword">enum</span> { 
00307         maxStrLen    = 4096,
00308         maxFreeVars  = 4
00309     };
00310 
00311     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table;
00312     <a class="code" href="classdbQueryElement.html">dbQueryElement</a>*    queryElement;
00313     <span class="keywordtype">int</span>                currPos;
00314     <span class="keywordtype">int</span>                firstPos;
00315     <span class="keywordtype">int</span>                offsetWithinStatement;
00316     <span class="keywordtype">int</span>                bvalue;
00317     db_int8            ivalue;
00318     real8              fvalue;
00319     dbStrLiteral       svalue;
00320     <span class="keywordtype">bool</span>               hasToken;
00321     <span class="keywordtype">int</span>                lex;
00322     <span class="keywordtype">char</span>*              name;
00323     dbBinding*         bindings;
00324     <span class="keywordtype">int</span>                nFreeVars;
00325     <span class="keywordtype">int</span>                varType;
00326     <span class="keywordtype">void</span> <span class="keyword">const</span>*        varPtr;
00327     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* varRefTable;
00328 
00329     jmp_buf            abortCompilation;
00330     <span class="keyword">static</span> <span class="keywordtype">bool</span>        initialized;
00331 
00332     <span class="keywordtype">void</span>        compare(dbExprNode* expr, dbExprNode* list);
00333 
00334     <span class="keywordtype">int</span>         scan();
00335     <span class="keywordtype">void</span>        ungetToken(<span class="keywordtype">int</span> tkn) {
00336         lex = tkn;
00337         hasToken = <span class="keyword">true</span>;
00338     }
00339     <span class="keywordtype">void</span>        error(<span class="keyword">const</span> <span class="keywordtype">char</span>* msg, <span class="keywordtype">int</span> pos = -1);
00340     dbExprNode* conjunction();    
00341     dbExprNode* disjunction();
00342     dbExprNode* comparison();    
00343     dbExprNode* addition();    
00344     dbExprNode* multiplication();    
00345     dbExprNode* power();
00346     dbExprNode* term();
00347     dbExprNode* buildList();
00348     dbExprNode* userDefinedOperator();
00349     dbExprNode* field(dbExprNode* expr, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* refTable,
00350                       <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
00351 
00352     <span class="keywordtype">bool</span>        compile(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
00353     dbExprNode* compileExpression(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table,  <span class="keywordtype">char</span> <span class="keyword">const</span>* expr, <span class="keywordtype">int</span> startPos);
00354     <span class="keywordtype">void</span>        compileOrderByPart(<a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
00355     <span class="keywordtype">void</span>        compileLimitPart(<a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
00356     <span class="keywordtype">void</span>        compileStartFollowPart(<a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
00357 
00358     <span class="keywordtype">void</span>        deleteNode(dbExprNode* node);
00359     dbExprNode* rectangleConstant(dbExprNode* head);     
00360 
00361     dbCompiler();
00362 };
00363 
00364 <span class="keyword">class </span>dbDatabaseThreadContext : <span class="keyword">public</span> <a class="code" href="classdbL2List.html">dbL2List</a> { 
00365   <span class="keyword">public</span>:
00366     <span class="keywordtype">int</span> readAccess;
00367     <span class="keywordtype">int</span> writeAccess;
00368     <span class="keywordtype">int</span> concurrentId;
00369     <span class="keywordtype">int</span> mutatorCSLocked;
00370     <span class="keywordtype">int</span> isMutator;
00371 
00372     <a class="code" href="classdbL2List.html">dbL2List</a> cursors; 
00373     
00374     dbCompiler compiler;
00375 
00376     dbProcessId currPid;
00377 
00378     <span class="keywordtype">bool</span>     interactive;
00379     <span class="keywordtype">bool</span>     catched;
00380     <span class="keywordtype">bool</span>     commitDelayed;
00381     <span class="keywordtype">bool</span>     removeContext;
00382     jmp_buf  unwind;
00383     
00384     dbDatabaseThreadContext() { 
00385         concurrentId = 0;
00386         readAccess = <span class="keyword">false</span>;
00387         writeAccess = <span class="keyword">false</span>;
00388         mutatorCSLocked = <span class="keyword">false</span>;
00389         isMutator = <span class="keyword">false</span>;
00390         interactive = <span class="keyword">false</span>;
00391         catched = <span class="keyword">false</span>;
00392         commitDelayed = <span class="keyword">false</span>;
00393         removeContext = <span class="keyword">false</span>;
00394         currPid = dbProcessId::getCurrent();
00395     }
00396 };
00397 
00398 <span class="keyword">union </span>dbSynthesizedAttribute { 
00399     byte*     base;
00400     <span class="keywordtype">int</span>       bvalue;
00401     db_int8   ivalue;
00402     real8     fvalue;
00403     <a class="code" href="classrectangle.html">rectangle</a> rvalue;
00404     <span class="keywordtype">void</span>*     raw;
00405     oid_t     oid;
00406 
00407     <span class="keyword">struct </span>{ 
00408         <span class="keywordtype">char</span>* base;
00409         <span class="keywordtype">int</span>   size;
00410     } array;
00411 };
00412 
00413 <span class="keyword">struct </span>dbStringValue;
00414 
00415 <span class="keyword">struct </span>FASTDB_DLL_ENTRY dbInheritedAttribute { 
00416     byte*          record;
00417     oid_t          oid;
00418     <a class="code" href="classdbTable.html">dbTable</a>*       table;
00419     <a class="code" href="classdbDatabase.html">dbDatabase</a>*    db;
00420     dbStringValue* tempStrings;
00421     size_t         paramBase;
00422     <span class="keyword">enum</span> { 
00423         internalStrBufSize = 8*1024 
00424     };
00425     size_t         strBufPos;
00426     <span class="keywordtype">char</span>           strBuf[internalStrBufSize];
00427     
00428     <span class="keyword">struct </span>{ 
00429         <span class="keywordtype">int</span>     index;
00430         jmp_buf unwind;
00431     } exists_iterator[dbCompiler::maxFreeVars];
00432 
00433     <span class="keywordtype">void</span> removeTemporaries();
00434 
00435     dbInheritedAttribute() { 
00436         tempStrings = NULL;
00437         strBufPos = 0;
00438     }
00439 
00440     ~dbInheritedAttribute() { 
00441         removeTemporaries(); 
00442     }
00443 };
00444 
00445 <span class="keyword">struct </span>dbStringValue { 
00446     dbStringValue* next;
00447     <span class="keywordtype">char</span>           str[1];
00448 
00449     <span class="keyword">static</span> <span class="keywordtype">char</span>* create(size_t size, dbInheritedAttribute&amp; attr) { 
00450         <span class="keywordflow">if</span> (attr.strBufPos + size &gt; <span class="keyword">sizeof</span>(attr.strBuf)) { 
00451             dbStringValue* sv = 
00452                 (dbStringValue*)<span class="keyword">new</span> <span class="keywordtype">char</span>[offsetof(dbStringValue, str) + size];
00453             sv-&gt;next = attr.tempStrings;
00454             attr.tempStrings = sv;
00455             <span class="keywordflow">return</span> sv-&gt;str;
00456         } <span class="keywordflow">else</span> { 
00457             <span class="keywordtype">char</span>* p = attr.strBuf + attr.strBufPos;
00458             attr.strBufPos += size;
00459             <span class="keywordflow">return</span> p;
00460         }
00461     }
00462 
00463     <span class="keyword">static</span> <span class="keywordtype">char</span>* create(<span class="keywordtype">char</span> <span class="keyword">const</span>* s, dbInheritedAttribute&amp; attr) {
00464         size_t len = strlen(s) + 1;
00465         <span class="keywordtype">char</span>*  buf;
00466         <span class="keywordflow">if</span> (attr.strBufPos + len &gt; <span class="keyword">sizeof</span>(attr.strBuf)) { 
00467             dbStringValue* sv = 
00468                 (dbStringValue*)<span class="keyword">new</span> <span class="keywordtype">char</span>[offsetof(dbStringValue,str)+len];
00469             sv-&gt;next = attr.tempStrings;
00470             attr.tempStrings = sv;
00471             buf = sv-&gt;str;
00472         } <span class="keywordflow">else</span> { 
00473             buf = attr.strBuf + attr.strBufPos;
00474             attr.strBufPos += len;
00475         }
00476         <span class="keywordflow">return</span> strcpy(buf, s);
00477     }
00478 };
00479 
00480 <span class="keyword">inline</span> <span class="keywordtype">char</span>* findWildcard(<span class="keywordtype">char</span>* pattern, <span class="keywordtype">char</span>* escape = NULL) 
00481 {
00482     <span class="keywordflow">if</span> (escape == NULL) { 
00483         <span class="keywordflow">while</span> (*pattern != dbMatchAnyOneChar &amp;&amp;
00484                *pattern != dbMatchAnySubstring)
00485         {
00486             <span class="keywordflow">if</span> (*pattern++ == <span class="charliteral">'\0'</span>) { 
00487                 <span class="keywordflow">return</span> NULL;
00488             }
00489         }
00490     } <span class="keywordflow">else</span> { 
00491         <span class="keywordtype">char</span> esc = *escape;
00492         <span class="keywordflow">while</span> (*pattern != dbMatchAnyOneChar &amp;&amp;
00493                *pattern != dbMatchAnySubstring &amp;&amp;
00494                *pattern != esc)
00495         {
00496             <span class="keywordflow">if</span> (*pattern++ == <span class="charliteral">'\0'</span>) { 
00497                 <span class="keywordflow">return</span> NULL;
00498             }
00499         }
00500     }
00501     <span class="keywordflow">return</span> pattern;
00502 }
00503         
00504 END_FASTDB_NAMESPACE
00505     
00506 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Thu Feb 14 12:42:30 2008 for FastDB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
