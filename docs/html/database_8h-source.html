<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>database.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>database.h</h1><div class="fragment"><pre>00001 <span class="comment">//-&lt; DATABASE.H &gt;----------------------------------------------------*--------*</span>
00002 <span class="comment">// FastDB                    Version 1.0         (c) 1999  GARRET    *     ?  *</span>
00003 <span class="comment">// (Main Memory Database Management System)                          *   /\|  *</span>
00004 <span class="comment">//                                                                   *  /  \  *</span>
00005 <span class="comment">//                          Created:     20-Nov-98    K.A. Knizhnik  * / [] \ *</span>
00006 <span class="comment">//                          Last update: 23-Dec-98    K.A. Knizhnik  * GARRET *</span>
00007 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00008 <span class="comment">// Database management</span>
00009 <span class="comment">//-------------------------------------------------------------------*--------*</span>
00010 
00011 <span class="preprocessor">#ifndef __DATABASE_H__</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define __DATABASE_H__</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#include "class.h"</span>
00015 <span class="preprocessor">#include "reference.h"</span>
00016 <span class="preprocessor">#include "file.h"</span>
00017 
00018 BEGIN_FASTDB_NAMESPACE
00019 
00023 <span class="preprocessor">#ifdef DISKLESS_CONFIGURATION</span>
00024 <span class="preprocessor"></span><span class="comment">// In diskless confiuration database can not be reallocated</span>
00025 <span class="keyword">const</span> size_t dbDefaultInitDatabaseSize = 32*1024*1024;
00026 <span class="preprocessor">#else</span>
00027 <span class="preprocessor"></span><span class="keyword">const</span> size_t dbDefaultInitDatabaseSize = 1024*1024;
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00033 <span class="keyword">const</span> size_t dbDefaultInitIndexSize = 512*1024;
00034 
00038 <span class="keyword">const</span> size_t dbDefaultExtensionQuantum = 4*1024*1024;
00039 
00043 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> dbMaxParallelSearchThreads = 64;
00044 
00045 <span class="keyword">const</span> <span class="keywordtype">int</span> dbDefaultParallelScanThreshold = 1000;
00046 <span class="keyword">const</span> <span class="keywordtype">int</span> dbDefaultPollInterval = 100*1000; <span class="comment">// milliseconds</span>
00047 <span class="keyword">const</span> <span class="keywordtype">int</span> dbOpenPollInterval = 1000; <span class="comment">// milliseconds</span>
00048 <span class="keyword">const</span> <span class="keywordtype">int</span> dbWaitReadyTimeout = 60*1000; <span class="comment">// milliseconds</span>
00049 <span class="keyword">const</span> <span class="keywordtype">int</span> dbWaitStatusTimeout = 60*1000; <span class="comment">// milliseconds </span>
00050 <span class="keyword">const</span> <span class="keywordtype">int</span> dbRecoveryConnectionAttempts = 3; 
00051 <span class="keyword">const</span> <span class="keywordtype">int</span> dbStartupConnectionAttempts = 60;
00052 <span class="keyword">const</span> <span class="keywordtype">int</span> dbReplicationWriteTimeout = 60*1000; <span class="comment">// milliseconds </span>
00053 <span class="keyword">const</span> <span class="keywordtype">int</span> dbMaxAsyncRecoveryIterations = 1000;   
00054 <span class="keyword">const</span> <span class="keywordtype">int</span> dbTableHashSize = 1009;   
00055 
00059 <span class="keyword">enum</span> dbInternalObject { 
00060     dbTableRow, 
00061     dbPageObjectMarker,
00062     dbTtreeMarker,
00063     dbTtreeNodeMarker,
00064     dbHashTableMarker,
00065     dbHashTableItemMarker,
00066     dbRtreeMarker,
00067     dbRtreePageMarker,
00068     
00069     dbInternalObjectMarker = 7 <span class="comment">// mask for internals object markers</span>
00070 };
00071     
00072 <span class="keyword">const</span> offs_t dbFreeHandleMarker = (offs_t)1 &lt;&lt; (<span class="keyword">sizeof</span>(offs_t)*8 - 1); 
00073 
00074 <span class="keyword">const</span> size_t dbAllocationQuantumBits = 4;
00075 <span class="keyword">const</span> size_t dbAllocationQuantum = 1 &lt;&lt; dbAllocationQuantumBits;
00076 <span class="keyword">const</span> size_t dbPageBits = 12;
00077 <span class="keyword">const</span> size_t dbPageSize = 1 &lt;&lt; dbPageBits;
00078 <span class="keyword">const</span> size_t dbIdsPerPage = dbPageSize / <span class="keyword">sizeof</span>(oid_t);
00079 <span class="keyword">const</span> size_t dbHandlesPerPage = dbPageSize / <span class="keyword">sizeof</span>(offs_t);
00080 <span class="keyword">const</span> size_t dbHandleBits = 1 + <span class="keyword">sizeof</span>(offs_t)/4; <span class="comment">// log(sizeof(offs_t))</span>
00081 <span class="keyword">const</span> size_t dbBitmapSegmentBits = dbPageBits + 3 + dbAllocationQuantumBits;
00082 <span class="keyword">const</span> size_t dbBitmapSegmentSize = 1 &lt;&lt; dbBitmapSegmentBits;
00083 <span class="keyword">const</span> size_t dbBitmapPages = 1 &lt;&lt; (dbDatabaseOffsetBits-dbBitmapSegmentBits);
00084 <span class="keyword">const</span> size_t dbDirtyPageBitmapSize = 1 &lt;&lt; (dbDatabaseOidBits-dbPageBits+dbHandleBits-3);
00085 <span class="keyword">const</span> size_t dbDefaultSelectionLimit = 2000000000;
00086 
00087 <span class="keyword">const</span> <span class="keywordtype">int</span>    dbBMsearchThreshold = 512;
00088 
00089 <span class="keyword">const</span> <span class="keywordtype">char</span>   dbMatchAnyOneChar = <span class="charliteral">'_'</span>;
00090 <span class="keyword">const</span> <span class="keywordtype">char</span>   dbMatchAnySubstring = <span class="charliteral">'%'</span>;
00091 
00092 <span class="keyword">const</span> <span class="keywordtype">int</span>    dbMaxReaders = 64; <span class="comment">// maximal number of readers concurrently accessing the database</span>
00093 
00097 <span class="keyword">enum</span> dbPredefinedIds { 
00098     dbInvalidId,
00099     dbMetaTableId, 
00100     dbBitmapId,
00101     dbFirstUserId = dbBitmapId + dbBitmapPages
00102 };
00103 
<a name="l00107"></a><a class="code" href="classdbHeader.html">00107</a> <span class="keyword">class </span><a class="code" href="classdbHeader.html">dbHeader</a> { 
00108   <span class="keyword">public</span>:
00109     offs_t size;  <span class="comment">// database file size</span>
00110     int4   curr;  <span class="comment">// current root</span>
00111     int4   dirty; <span class="comment">// database was not closed normally</span>
00112     int4   initialized; <span class="comment">// database is initilaized</span>
00113 <span class="preprocessor">#if (dbDatabaseOffsetBits &gt; 32 &amp;&amp; defined(ALIGN_HEADER)) || defined(PAD_HEADER)</span>
00114 <span class="preprocessor"></span>    int4   pad;
00115 <span class="preprocessor">#endif</span>
00116 <span class="preprocessor"></span>    <span class="keyword">struct </span>{ 
00117         offs_t index;           <span class="comment">// offset to object index</span>
00118         offs_t shadowIndex;     <span class="comment">// offset to shadow index</span>
00119         oid_t  indexSize;       <span class="comment">// size of object index</span>
00120         oid_t  shadowIndexSize; <span class="comment">// size of object index</span>
00121         oid_t  indexUsed;       <span class="comment">// used part of the index   </span>
00122         oid_t  freeList;        <span class="comment">// L1 list of free descriptors</span>
00123     } root[2];
00124     
00125     int4 majorVersion;
00126     int4 minorVersion;
00127     int4 mode;
00128 
00129     <span class="keyword">enum</span> { 
00130         MODE_OID_64        = 0x01,
00131         MODE_OFFS_64       = 0x02,
00132         MODE_AUTOINCREMENT = 0x04,
00133         MODE_RECTANGLE_DIM = 0x08
00134     };    
00135 
00136     <span class="keywordtype">int</span> getVersion() { 
00137         <span class="keywordflow">return</span> majorVersion*100 + minorVersion;
00138     }
00139     
00140     <span class="keywordtype">bool</span> isCompatible();
00141     <span class="keyword">static</span> <span class="keywordtype">int</span> getCurrentMode();
00142 };
00143 
00144 <span class="keyword">union  </span>dbSynthesizedAttribute;
00145 <span class="keyword">struct </span>dbInheritedAttribute;
00146 <span class="keyword">class </span>dbDatabaseThreadContext;
00147 <span class="keyword">class </span><a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>;
00148 <span class="keyword">class </span><a class="code" href="classdbQuery.html">dbQuery</a>;
00149 <span class="keyword">class </span>dbExprNode;
00150 
00151 <span class="keyword">struct </span>dbMemoryStatistic { 
00152     offs_t used;
00153     offs_t free;
00154     offs_t nHoles;
00155     offs_t minHoleSize;
00156     offs_t maxHoleSize;
00157     size_t nHolesOfSize[dbDatabaseOffsetBits];
00158 };
00159 
00160 <span class="keyword">class </span>FixedSizeAllocator
00161 {
00162     <span class="keyword">struct </span>Hole { 
00163         Hole*  next;
00164         offs_t offs;
00165     };
00166 
00167     size_t minSize;
00168     size_t maxSize;
00169     size_t quantum;
00170     size_t nChains;
00171     size_t bufSize;
00172     Hole** chains;
00173     Hole*  vacant;
00174     Hole*  holes;
00175 
00176   <span class="keyword">public</span>:
00177     size_t hits;
00178     size_t faults;
00179     size_t retries;
00180 
00181     FixedSizeAllocator();
00182     ~FixedSizeAllocator();
00183        
00184     <span class="keywordtype">void</span> init(size_t minSize, size_t maxSize, size_t quantum, size_t bufSize);
00185     <span class="keywordtype">void</span> reset();
00186 
00187     offs_t allocate(size_t size) { 
00188         <span class="keywordflow">if</span> (size - minSize &lt;= maxSize - minSize) { 
00189             size_t i = (size - minSize + quantum - 1) / quantum;
00190             Hole* hole = chains[i];
00191             <span class="keywordflow">if</span> (hole != NULL) { 
00192                 hits += 1;
00193                 chains[i] = hole-&gt;next;
00194                 hole-&gt;next = vacant;
00195                 vacant = hole;
00196                 <span class="keywordflow">return</span> hole-&gt;offs;
00197             }            
00198             faults += 1;
00199         }
00200         <span class="keywordflow">return</span> 0;
00201     }
00202     
00203     <span class="keywordtype">bool</span> free(offs_t offs, size_t size) { 
00204         <span class="keywordflow">if</span> (vacant != NULL &amp;&amp; size - minSize &lt;= maxSize - minSize) {             
00205             size_t i = (size - minSize + quantum - 1) / quantum;
00206             Hole* hole = vacant;
00207             vacant = hole-&gt;next;
00208             hole-&gt;next = chains[i];
00209             chains[i] = hole;
00210             hole-&gt;offs = offs;
00211             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00212         }
00213         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00214     }   
00215 };
00216 
00217 
00218 <span class="keyword">class </span>dbMonitor { 
00219   <span class="keyword">public</span>:
00220     sharedsem_t sem;
00221     sharedsem_t mutatorSem;
00222     <span class="keywordtype">int</span>  nReaders;
00223     <span class="keywordtype">int</span>  nWriters;
00224     <span class="keywordtype">int</span>  nConcurrentWriters;
00225     <span class="keywordtype">int</span>  nWaitReaders;
00226     <span class="keywordtype">int</span>  nWaitWriters;
00227     <span class="keywordtype">int</span>  waitForUpgrade;
00228     <span class="keywordtype">int</span>  forceCommitCount;
00229     <span class="keywordtype">int</span>  backupInProgress;
00230     <span class="keywordtype">int</span>  uncommittedChanges;
00231 
00232     <span class="keywordtype">int</span>  curr;             <span class="comment">// copy of header-&gt;root, used to allow read access </span>
00233                            <span class="comment">// to the database during transaction commit</span>
00234     offs_t size; <span class="comment">// database size</span>
00235 
00236     <span class="keywordtype">int</span>  commitInProgress;
00237     <span class="keywordtype">int</span>  concurrentTransId;
00238 
00239     <span class="keywordtype">unsigned</span> lastDeadlockRecoveryTime;
00240 
00241     <span class="keywordtype">int</span>  version; 
00242     <span class="keywordtype">int</span>  users;  
00243 
00244     dbProcessId ownerPid;
00245 
00246     dbDatabaseThreadContext*  delayedCommitContext;     <span class="comment">// save context of delayed transaction</span>
00247 
00248     int4 dirtyPagesMap[dbDirtyPageBitmapSize/4];
00249 
00250     <span class="keywordtype">int</span>  sharedLockOwner[dbMaxReaders];
00251     <span class="keywordtype">int</span>  exclusiveLockOwner;
00252     <span class="keywordtype">int</span>  clientId;
00253     <span class="keywordtype">int</span>  upgradeId;
00254 
00255     <span class="keywordtype">int</span>  modified;
00256 
00257 <span class="preprocessor">#ifdef DO_NOT_REUSE_OID_WITHIN_SESSION</span>
00258 <span class="preprocessor"></span>    <span class="keyword">struct </span>{ 
00259         oid_t head;
00260         oid_t tail;
00261     } sessionFreeList[2];
00262 <span class="preprocessor">#endif</span>
00263 <span class="preprocessor"></span>};
00264 
<a name="l00268"></a><a class="code" href="classdbL2List.html">00268</a> <span class="keyword">class </span>FASTDB_DLL_ENTRY <a class="code" href="classdbL2List.html">dbL2List</a> { 
00269   <span class="keyword">public</span>:
00270     <a class="code" href="classdbL2List.html">dbL2List</a>* next; 
00271     <a class="code" href="classdbL2List.html">dbL2List</a>* prev; 
00272 
00273     <span class="keywordtype">void</span> link(<a class="code" href="classdbL2List.html">dbL2List</a>* elem) { 
00274         elem-&gt;<a class="code" href="classdbL2List.html#dbL2Listm1">prev</a> = <span class="keyword">this</span>;
00275         elem-&gt;<a class="code" href="classdbL2List.html#dbL2Listm0">next</a> = next;
00276         next = next-&gt;<a class="code" href="classdbL2List.html#dbL2Listm1">prev</a> = elem;
00277     }
00278     <span class="keywordtype">void</span> unlink() { 
00279         next-&gt;<a class="code" href="classdbL2List.html#dbL2Listm1">prev</a> = prev;
00280         prev-&gt;<a class="code" href="classdbL2List.html#dbL2Listm0">next</a> = next;
00281         next = prev = <span class="keyword">this</span>;
00282     }
00283     <span class="keywordtype">bool</span> isEmpty() { 
00284         <span class="keywordflow">return</span> next == <span class="keyword">this</span>;
00285     }
00286     <span class="keywordtype">void</span> reset() { 
00287         next = prev = <span class="keyword">this</span>;
00288     }        
00289     <a class="code" href="classdbL2List.html">dbL2List</a>() { 
00290         next = prev = <span class="keyword">this</span>;
00291     }
00292     ~<a class="code" href="classdbL2List.html">dbL2List</a>() { 
00293         unlink();
00294     }
00295 };
00296 
00297 <span class="keyword">class </span>dbVisitedObject {
00298   <span class="keyword">public</span>: 
00299     dbVisitedObject* next;
00300     oid_t            oid;
00301 
00302     dbVisitedObject(oid_t oid, dbVisitedObject* chain) {         
00303         this-&gt;oid = oid;
00304         next = chain;
00305     }
00306 };
00307     
00308 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
00309 <span class="preprocessor"></span><span class="keyword">struct </span>dbWatchDogContext : <a class="code" href="classdbL2List.html">dbL2List</a> { 
00310     dbThread    thread;
00311     dbWatchDog  watchDog;
00312     <span class="keywordtype">int</span>         clientId;
00313     <a class="code" href="classdbDatabase.html">dbDatabase</a>* db;
00314     dbMutex*    mutex;
00315 };
00316 <span class="preprocessor">#endif</span>
00317 <span class="preprocessor"></span>
00318 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
00319 <span class="keyword">class </span>dbHArray;
00320 
00321 <span class="keyword">class </span>dbXmlContext;
00322 <span class="keyword">class </span>dbXmlScanner;
00323 
00324 <span class="keyword">typedef</span> unsigned (*dbHashFunction)(byte* key, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> keylen);
00325     
<a name="l00329"></a><a class="code" href="classdbDatabase.html">00329</a> <span class="keyword">class </span>FASTDB_DLL_ENTRY dbDatabase { 
00330     <span class="keyword">friend</span> <span class="keyword">class </span>dbSelection;
00331     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>;
00332     <span class="keyword">friend</span> <span class="keyword">class </span>dbHashTable;
00333     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbQuery.html">dbQuery</a>;
00334     <span class="keyword">friend</span> <span class="keyword">class </span>dbTtree;
00335     <span class="keyword">friend</span> <span class="keyword">class </span>dbTtreeNode;
00336     <span class="keyword">friend</span> <span class="keyword">class </span>dbRtree;
00337     <span class="keyword">friend</span> <span class="keyword">class </span>dbRtreePage;
00338     <span class="keyword">friend</span> <span class="keyword">class </span>dbParallelQueryContext; 
00339     <span class="keyword">friend</span> <span class="keyword">class </span>dbServer;
00340     <span class="keyword">friend</span> <span class="keyword">class </span>dbColumnBinding;
00341     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbUserFunctionArgument.html">dbUserFunctionArgument</a>;
00342     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classdbAnyContainer.html">dbAnyContainer</a>;
00343     <span class="keyword">friend</span> <span class="keyword">class </span>dbFile;
00344     <span class="keyword">friend</span> <span class="keyword">class </span>dbCLI;
00345     <span class="keyword">friend</span> <span class="keyword">class </span>GiSTdb;
00346 
00347 <span class="preprocessor">#ifdef HAS_TEMPLATE_FRIENDS</span>
00348 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
00349     <span class="keyword">friend</span> <span class="keyword">class </span>dbHArray;
00350 <span class="preprocessor">#else</span>
00351 <span class="preprocessor"></span>    <span class="keyword">friend</span> <span class="keyword">class </span>dbAnyHArray;
00352 <span class="preprocessor">#endif</span>
00353 <span class="preprocessor"></span>
00354   <span class="keyword">public</span>:
00364     <span class="keywordtype">bool</span> open(<span class="keywordtype">char</span> <span class="keyword">const</span>* databaseName, 
00365               <span class="keywordtype">char</span> <span class="keyword">const</span>* fileName = NULL, 
00366               time_t waitLockTimeoutMsec = INFINITE, 
00367               time_t commitDelaySec = 0);
00368 
00369     <span class="keyword">enum</span> dbAccessType { 
00370         dbReadOnly,
00371         dbAllAccess,
00372         dbConcurrentRead,
00373         dbConcurrentUpdate
00374     };
00375 
<a name="l00379"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html">00379</a>     <span class="keyword">struct </span><a class="code" href="structdbDatabase_1_1OpenParameters.html">OpenParameters</a> { 
<a name="l00383"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm0">00383</a>         <span class="keywordtype">char</span> <span class="keyword">const</span>* databaseName;
00384 
<a name="l00388"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm1">00388</a>         <span class="keywordtype">char</span> <span class="keyword">const</span>* databaseFilePath;
00389         
<a name="l00393"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm2">00393</a>         time_t  transactionCommitDelay;
00394 
<a name="l00398"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm3">00398</a>         time_t waitLockTimeoutMsec;
00399 
<a name="l00403"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm4">00403</a>         dbAccessType accessType;
00404 
<a name="l00408"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm5">00408</a>         size_t initSize;
00409 
<a name="l00413"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm6">00413</a>         size_t extensionQuantum;
00414             
<a name="l00418"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm7">00418</a>         size_t initIndexSize;
00419 
<a name="l00423"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm8">00423</a>         <span class="keywordtype">int</span> nThreads;
00424 
<a name="l00429"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm9">00429</a>         offs_t freeSpaceReuseThreshold;
00430 
<a name="l00434"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm10">00434</a>         <span class="keywordtype">int</span> parallelScanThreshold;
00435 
<a name="l00439"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm11">00439</a>         <span class="keywordtype">int</span> nodeId;
00440 
<a name="l00444"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm12">00444</a>         <span class="keywordtype">char</span>** nodeAddresses;
00445 
<a name="l00449"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm13">00449</a>         <span class="keywordtype">int</span> nNodes;
00450         
<a name="l00454"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm14">00454</a>         <span class="keywordtype">int</span> pollInterval; <span class="comment">// milliseconds</span>
00455 
<a name="l00459"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm15">00459</a>         <span class="keywordtype">int</span> waitReadyTimeout; <span class="comment">// milliseconds</span>
00460 
<a name="l00464"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm16">00464</a>         <span class="keywordtype">int</span> waitStatusTimeout; <span class="comment">// milliseconds </span>
00465 
<a name="l00469"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm17">00469</a>         <span class="keywordtype">int</span> recoveryConnectionAttempts; 
00470 
<a name="l00474"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm18">00474</a>         <span class="keywordtype">int</span> startupConnectionAttempts;
00475 
<a name="l00481"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm19">00481</a>         <span class="keywordtype">int</span> replicationWriteTimeout;
00482 
<a name="l00488"></a><a class="code" href="structdbDatabase_1_1OpenParameters.html#dbDatabase_1_1OpenParametersm20">00488</a>         <span class="keywordtype">int</span> maxAsyncRecoveryIterations;
00489 
00490         <a class="code" href="structdbDatabase_1_1OpenParameters.html">OpenParameters</a>() { 
00491             databaseName = NULL;
00492             databaseFilePath = NULL;
00493             transactionCommitDelay = 0;
00494             waitLockTimeoutMsec = INFINITE;
00495             accessType = dbAllAccess;
00496             extensionQuantum = dbDefaultExtensionQuantum;
00497             initSize = dbDefaultInitDatabaseSize;
00498             initIndexSize = dbDefaultInitIndexSize;
00499             nThreads = 1;
00500             freeSpaceReuseThreshold = dbDefaultExtensionQuantum;
00501             nodeId = 0;
00502             nodeAddresses = NULL;
00503             nNodes = 0;
00504             parallelScanThreshold = dbDefaultParallelScanThreshold;
00505             pollInterval = dbDefaultPollInterval;
00506             waitReadyTimeout = dbWaitReadyTimeout;
00507             waitStatusTimeout = dbWaitStatusTimeout;
00508             recoveryConnectionAttempts = dbRecoveryConnectionAttempts; 
00509             startupConnectionAttempts = dbStartupConnectionAttempts;
00510             replicationWriteTimeout = dbReplicationWriteTimeout;
00511             maxAsyncRecoveryIterations = dbMaxAsyncRecoveryIterations;   
00512         }
00513     };
00514 
00520     <span class="keywordtype">bool</span> open(OpenParameters&amp; params);
00521 
00525     <span class="keywordtype">void</span> close();
00526 
00530     <span class="keywordtype">void</span> commit();
00531 
00536     <span class="keywordtype">void</span> precommit();
00537     
00541     <span class="keywordtype">void</span> rollback();
00542 
00549     <span class="keywordtype">void</span> scheduleBackup(<span class="keywordtype">char</span> <span class="keyword">const</span>* fileName, time_t periodSec);
00550     
00555     <span class="keywordtype">void</span> attach();
00556     
00562     <span class="keywordtype">void</span> attach(dbDatabaseThreadContext* ctx);
00563 
00564 
00565     <span class="keyword">enum</span> DetachFlags { 
00566         COMMIT          = 1,
00567         DESTROY_CONTEXT = 2
00568     };
00573     <span class="keywordtype">void</span> detach(<span class="keywordtype">int</span> flags = COMMIT|DESTROY_CONTEXT);
00574 
00575     <span class="keyword">enum</span> dbLockType { 
00576         dbSharedLock, 
00577         dbExclusiveLock,
00578         dbCommitLock
00579     };
00580 
<a name="l00584"></a><a class="code" href="classdbDatabase.html#dbSubSqla16">00584</a>     <span class="keywordtype">void</span> lock(dbLockType lock = dbExclusiveLock) { beginTransaction(lock); }
00585 
00594     <span class="keywordtype">bool</span> backup(<span class="keywordtype">char</span> <span class="keyword">const</span>* file, <span class="keywordtype">bool</span> compactify);
00595     
00605     <span class="keywordtype">bool</span> backup(dbFile* file, <span class="keywordtype">bool</span> compactify);
00606     
<a name="l00611"></a><a class="code" href="classdbDatabase.html#dbSubSqla19">00611</a>     <span class="keywordtype">void</span> assign(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>&amp; desc) { 
00612         assert(((<span class="keywordtype">void</span>)<span class="stringliteral">"Table is not yet assigned to the database"</span>, 
00613                 desc.<a class="code" href="classdbTableDescriptor.html#dbTableDescriptorn3">tableId</a> == 0));
00614         desc.<a class="code" href="classdbTableDescriptor.html#dbTableDescriptorn10">db</a> = <span class="keyword">this</span>; 
00615         desc.<a class="code" href="classdbTableDescriptor.html#dbTableDescriptorn11">fixedDatabase</a> = <span class="keyword">true</span>;
00616     }
00617 
00625     <span class="keywordtype">void</span> setConcurrency(<span class="keywordtype">unsigned</span> nThreads);
00626 
<a name="l00631"></a><a class="code" href="classdbDatabase.html#dbSubSqla21">00631</a>     <span class="keywordtype">long</span> getAllocatedSize() { <span class="keywordflow">return</span> allocatedSize; }
00632 
<a name="l00637"></a><a class="code" href="classdbDatabase.html#dbSubSqla22">00637</a>     <span class="keywordtype">long</span> getDatabaseSize() { <span class="keywordflow">return</span> header-&gt;size; }
00638 
<a name="l00643"></a><a class="code" href="classdbDatabase.html#dbSubSqla23">00643</a>     <span class="keywordtype">int</span> getNumberOfReaders() { 
00644         <span class="keywordflow">return</span> monitor-&gt;nReaders;
00645     }
00646 
<a name="l00651"></a><a class="code" href="classdbDatabase.html#dbSubSqla24">00651</a>     <span class="keywordtype">int</span> getNumberOfWriters() { 
00652         <span class="keywordflow">return</span> monitor-&gt;nWriters;
00653     }
00654 
<a name="l00659"></a><a class="code" href="classdbDatabase.html#dbSubSqla25">00659</a>     <span class="keywordtype">int</span> getNumberOfBlockedReaders() { 
00660         <span class="keywordflow">return</span> monitor-&gt;nReaders;
00661     }
00662 
<a name="l00667"></a><a class="code" href="classdbDatabase.html#dbSubSqla26">00667</a>     <span class="keywordtype">int</span> getNumberOfBlockedWriters() { 
00668         <span class="keywordflow">return</span> monitor-&gt;nWriters;
00669     }
00670 
<a name="l00675"></a><a class="code" href="classdbDatabase.html#dbSubSqla27">00675</a>     <span class="keywordtype">int</span> getNumberOfUsers() { 
00676         <span class="keywordflow">return</span> monitor-&gt;users;
00677     }
00678 
<a name="l00686"></a><a class="code" href="classdbDatabase.html#dbSubSqla28">00686</a>     <span class="keywordtype">void</span> allowColumnsDeletion(<span class="keywordtype">bool</span> enabled = <span class="keyword">true</span>) { 
00687         confirmDeleteColumns = enabled;
00688     }
00689 
00697     <span class="keywordtype">bool</span> prepareQuery(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
00698 
00699     <span class="keyword">enum</span> dbErrorClass { 
00700         NoError, 
00701         QueryError,
00702         ArithmeticError,
00703         IndexOutOfRangeError,
00704         DatabaseOpenError,
00705         FileError,
00706         OutOfMemoryError,
00707         Deadlock,
00708         NullReferenceError,
00709         LockRevoked,
00710         FileLimitExeeded,
00711         InconsistentInverseReference,
00712         DatabaseReadOnly,
00713         AssertionFailed
00714     };
00715     <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> errorMessage[];
00716     <span class="keyword">typedef</span> void (*dbErrorHandler)(<span class="keywordtype">int</span> error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg, <span class="keywordtype">int</span> msgarg, <span class="keywordtype">void</span>* context); 
00717 
00723     dbErrorHandler setErrorHandler(dbErrorHandler newHandler, <span class="keywordtype">void</span>* errorHandlerContext = NULL);
00724 
00732     <span class="keyword">virtual</span> <span class="keywordtype">void</span> handleError(dbErrorClass error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg = NULL, 
00733                              <span class="keywordtype">int</span> arg = 0); 
00734 
00743     <span class="keyword">virtual</span> <span class="keywordtype">void</span> formatErrorMessage(<span class="keywordtype">char</span>* buf, size_t bufSize, dbErrorClass error, <span class="keywordtype">char</span> <span class="keyword">const</span>* msg = NULL, <span class="keywordtype">int</span> arg = 0); 
00744 
00748     <span class="keyword">virtual</span> <span class="keywordtype">void</span> fatalError();
00749 
00756     <span class="keywordtype">void</span> insertRecord(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, <a class="code" href="classdbAnyReference.html">dbAnyReference</a>* ref, 
00757                       <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
00758 
<a name="l00762"></a><a class="code" href="classdbDatabase.html#dbSubSqla34">00762</a>     <span class="keywordtype">bool</span> isOpen()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> opened; }
00763 
00764 
00768     <span class="keywordtype">bool</span> isCommitted();
00769 
00773     <span class="keywordtype">bool</span> isAttached();
00774 
00778     <span class="keywordtype">bool</span> isUpdateTransaction();
00779 
00783     <span class="keywordtype">int</span>  getVersion();
00784 
<a name="l00789"></a><a class="code" href="classdbDatabase.html#dbSubSqla39">00789</a>     <span class="keywordtype">void</span> setFileSizeLimit(size_t limit) { 
00790         fileSizeLimit = limit;
00791     }
00792 
00793 <span class="preprocessor">#ifdef FUZZY_CHECKPOINT</span>
00794 <span class="preprocessor"></span>
00799     <span class="keywordtype">void</span> setFuzzyCheckpointBuffer(size_t nPages) { 
00800         file.setCheckpointBufferSize(nPages);
00801     }
00802 <span class="preprocessor">#endif</span>
00803 <span class="preprocessor"></span>
00804 <span class="preprocessor">#ifndef NO_MEMBER_TEMPLATES</span>
00805 <span class="preprocessor"></span>
00810     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00811"></a><a class="code" href="classdbDatabase.html#dbSubSqla40">00811</a>     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> insert(T <span class="keyword">const</span>&amp; record) {
00812         <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
00813         insertRecord(lookupTable(&amp;T::dbDescriptor), &amp;ref, &amp;record);
00814         <span class="keywordflow">return</span> ref;
00815     }
00816 <span class="preprocessor">#endif</span>
00817 <span class="preprocessor"></span>
00823     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* lookupTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
00824 
00829     <span class="keywordtype">void</span> getMemoryStatistic(dbMemoryStatistic&amp; stat);
00830 
<a name="l00835"></a><a class="code" href="classdbDatabase.html#dbSubSqla43">00835</a>     <span class="keywordtype">int</span> getNumberOfProceededTransactions() { 
00836         <span class="keywordflow">return</span> monitor-&gt;concurrentTransId - 1;
00837     }
00838 
<a name="l00844"></a><a class="code" href="classdbDatabase.html#dbDatabasea39">00844</a>     <span class="keywordtype">bool</span> isValidOid(oid_t oid) { 
00845         <span class="keywordflow">if</span> (oid &lt; dbFirstUserId || oid &gt;= currIndexSize) {
00846             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00847         }
00848         <span class="keywordflow">return</span> !(currIndex[oid]&amp;(dbFreeHandleMarker|dbInternalObjectMarker));
00849     }
00850 
00855     <span class="keywordtype">void</span> exportDatabaseToXml(FILE* out);
00856 
00862     <span class="keywordtype">bool</span> importDatabaseFromXml(FILE* in);
00863    
<a name="l00871"></a><a class="code" href="classdbDatabase.html#dbSubSqla46">00871</a>     <span class="keywordtype">void</span> setFixedSizeAllocator(size_t minSize, size_t maxSize, size_t quantum, size_t bufSize) { 
00872         fixedSizeAllocator.init(minSize, maxSize, quantum, bufSize);
00873     }
00874 
00875     <span class="keyword">enum</span> dbThreadMode {
00876         dbNotUsePthreads,
00877         dbUsePthreads
00878     };
00879 
00880     <span class="keyword">enum</span> dbReplicationMode {
00881         dbReplicated,
00882         dbStandalone
00883     };
00884        
00896     dbDatabase(dbAccessType type = dbAllAccess,
00897                size_t dbInitSize = dbDefaultInitDatabaseSize,
00898                size_t dbExtensionQuantum = dbDefaultExtensionQuantum,
00899                size_t dbInitIndexSize = dbDefaultInitIndexSize,
00900                <span class="keywordtype">int</span> nThreads = 1 
00901                <span class="comment">// Do not specify the following parameter - them are used only for checking</span>
00902                <span class="comment">// that application and FastDB library were built with the </span>
00903                <span class="comment">// same compiler options (-DNO_PTHREADS and -REPPLICATION_SUPPORT)</span>
00904                <span class="comment">// Mismached parameters should cause linker error</span>
00905 #ifdef NO_PTHREADS
00906                , dbThreadMode threadMode = dbNotUsePthreads
00907 #endif
00908 #ifdef REPLICATION_SUPPORT
00909                , dbReplicationMode replicationMode = dbReplicated
00910 #endif
00911                );
00915     <span class="keyword">virtual</span> ~dbDatabase(); 
00916 
00917     dbAccessType accessType;
00918     size_t initSize;
00919     size_t extensionQuantum;
00920     size_t initIndexSize;
00921     offs_t freeSpaceReuseThreshold;
00922 
00923   <span class="keyword">protected</span>:
00924     <span class="keyword">static</span> size_t internalObjectSize[];
00925 
00926     dbThreadPool threadPool;
00927 
00928     FixedSizeAllocator fixedSizeAllocator;
00929 
00930     dbThreadContext&lt;dbDatabaseThreadContext&gt; threadContext;
00931 
00932     byte*     baseAddr;         <span class="comment">// base address of database file mapping</span>
00933     <a class="code" href="classdbHeader.html">dbHeader</a>* header;           <span class="comment">// database header information</span>
00934     offs_t*   currIndex;        <span class="comment">// current database object index</span>
00935     offs_t*   index[2];
00936     <span class="keywordtype">unsigned</span>  parThreads;
00937     <span class="keywordtype">bool</span>      modified;
00938 
00939     size_t    currRBitmapPage;  <span class="comment">//current bitmap page for allocating records</span>
00940     size_t    currRBitmapOffs;  <span class="comment">//offset in current bitmap page for allocating</span>
00941                                 <span class="comment">//unaligned records</span>
00942     size_t    currPBitmapPage;  <span class="comment">//current bitmap page for allocating page objects</span>
00943     size_t    currPBitmapOffs;  <span class="comment">//offset in current bitmap page for allocating</span>
00944                                 <span class="comment">//page objects</span>
00945     <span class="keyword">struct </span>dbLocation { 
00946         offs_t      pos;
00947         size_t      size;
00948         dbLocation* next;
00949     };
00950     dbLocation* reservedChain;
00951     
00952     <span class="keywordtype">char</span>*     databaseName;
00953     <span class="keywordtype">int</span>       databaseNameLen;
00954     <span class="keywordtype">char</span>*     fileName;
00955     <span class="keywordtype">int</span>       version;
00956 
00957     size_t    committedIndexSize;
00958     size_t    currIndexSize;
00959     oid_t     updatedRecordId;
00960 
00961     <span class="keywordtype">unsigned</span>  waitLockTimeout;
00962 
00963     size_t    fileSizeLimit;
00964     <span class="keywordtype">bool</span>      uncommittedChanges;
00965 
00966     dbHashFunction hashFunction;
00967 
00968     dbFile                    file;
00969     dbSharedObject&lt;dbMonitor&gt; shm;
00970     dbGlobalCriticalSection   cs;
00971     dbGlobalCriticalSection   mutatorCS;
00972     dbInitializationMutex     initMutex;
00973     dbSemaphore               writeSem; 
00974     dbSemaphore               readSem; 
00975     dbSemaphore               upgradeSem; 
00976     dbEvent                   backupCompletedEvent;
00977     dbMonitor*                monitor;
00978 
00979     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>*        tables;
00980 
00981     <span class="keywordtype">int</span>*                      bitmapPageAvailableSpace;
00982     <span class="keywordtype">bool</span>                      opened;
00983 
00984     offs_t                    allocatedSize;
00985     offs_t                    deallocatedSize;
00986     
00987     time_t                    commitDelay;     
00988     time_t                    commitTimeout;
00989     time_t                    commitTimerStarted;
00990     
00991     dbMutex                   delayedCommitStartTimerMutex;
00992     dbMutex                   delayedCommitStopTimerMutex;
00993     dbLocalEvent              delayedCommitStartTimerEvent; 
00994     dbEvent                   delayedCommitStopTimerEvent; 
00995     dbLocalEvent              commitThreadSyncEvent;
00996     <span class="keywordtype">bool</span>                      delayedCommitEventsOpened;
00997 
00998     dbMutex                   backupMutex;    
00999     dbLocalEvent              backupInitEvent;
01000     <span class="keywordtype">char</span>*                     backupFileName;
01001     time_t                    backupPeriod;
01002     <span class="keywordtype">bool</span>                      stopDelayedCommitThread;
01003 
01004     dbThread                  backupThread;
01005     dbThread                  commitThread;
01006  
01007     <span class="keywordtype">int</span>                       accessCount;
01008 
01009     <a class="code" href="classdbL2List.html">dbL2List</a>                  threadContextList;
01010     dbMutex                   threadContextListMutex;
01011 
01012     dbErrorHandler            errorHandler;
01013     <span class="keywordtype">void</span>*                     errorHandlerContext;
01014     <span class="keywordtype">int</span>                       schemeVersion;
01015     dbVisitedObject*          visitedChain;
01016 
01017     <span class="keywordtype">bool</span>                      confirmDeleteColumns;
01018 
01019     <span class="keywordtype">int</span>                       maxClientId;
01020     <span class="keywordtype">int</span>                       selfId;
01021 
01022     dbXmlContext*             xmlContext;
01023 
01024 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
01025 <span class="preprocessor"></span>    dbWatchDog                selfWatchDog;
01026     <a class="code" href="classdbL2List.html">dbL2List</a>                  watchDogThreadContexts;
01027     dbMutex*                  watchDogMutex;
01028 <span class="preprocessor">#endif</span>
01029 <span class="preprocessor"></span>    
01030     <span class="keywordtype">unsigned</span> parallelScanThreshold; 
01031     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* tableHash[dbTableHashSize];
01032 
01033     <span class="keywordtype">void</span> exportScheme(FILE* out);
01034     <span class="keywordtype">void</span> exportClass(FILE* out, <span class="keywordtype">char</span>* name, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fieldList);
01035    
01036     oid_t mapId(<span class="keywordtype">long</span> id);
01037     <span class="keywordtype">bool</span> importField(<span class="keywordtype">char</span>* terminator, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, byte* rec, dbXmlScanner&amp; scanner);
01038     <span class="keywordtype">bool</span> importRecord(<span class="keywordtype">char</span>* terminator, <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fieldList, byte* rec, dbXmlScanner&amp; scanner);
01039     <span class="keywordtype">void</span> insertRecord(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t oid, <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
01040 
01046     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* loadMetaTable();
01047 
01048     <span class="keywordtype">void</span> cleanup(dbInitializationMutex::initializationStatus status, <span class="keywordtype">int</span> step);
01049 
01050     <span class="keywordtype">void</span> delayedCommit();
01051     <span class="keywordtype">void</span> backupScheduler();
01052 
01053     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc delayedCommitProc(<span class="keywordtype">void</span>* arg) { 
01054         ((dbDatabase*)arg)-&gt;delayedCommit();
01055     }
01056 
01057     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc backupSchedulerProc(<span class="keywordtype">void</span>* arg) { 
01058         ((dbDatabase*)arg)-&gt;backupScheduler();
01059     }
01060 
01061     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isReplicated();
01062 
01063     <span class="keyword">virtual</span> <span class="keywordtype">void</span> close0();
01064 
01065 <span class="preprocessor">#ifdef AUTO_DETECT_PROCESS_CRASH</span>
01066 <span class="preprocessor"></span>
01070     <span class="keywordtype">void</span> revokeLock(<span class="keywordtype">int</span> clientId);
01071 
01076     <span class="keyword">static</span> <span class="keywordtype">void</span> watchDogThread(dbWatchDogContext* ctx);
01077 
01081     <span class="keywordtype">void</span> startWatchDogThreads();
01082     
01086     <span class="keywordtype">void</span> addLockOwner();
01087 
01091     <span class="keywordtype">void</span> removeLockOwner(<span class="keywordtype">int</span> clientId);
01092 <span class="preprocessor">#endif</span>
01093 <span class="preprocessor"></span>
01098     <span class="keywordtype">void</span> commit(dbDatabaseThreadContext* ctx);
01099 
01104     <span class="keywordtype">void</span> restoreTablesConsistency();
01105 
<a name="l01111"></a><a class="code" href="classdbDatabase.html#dbSubSqlb14">01111</a>     <a class="code" href="classdbRecord.html">dbRecord</a>* getRow(oid_t oid) { 
01112         assert(!(currIndex[oid]&amp;(dbFreeHandleMarker|dbInternalObjectMarker)));
01113         <span class="keywordflow">return</span> (<a class="code" href="classdbRecord.html">dbRecord</a>*)(baseAddr + currIndex[oid]); 
01114     }
01115 
01125     <a class="code" href="classdbRecord.html">dbRecord</a>* putRow(oid_t oid, size_t newSize); 
01126 
<a name="l01132"></a><a class="code" href="classdbDatabase.html#dbSubSqlb16">01132</a>     <a class="code" href="classdbRecord.html">dbRecord</a>* putRow(oid_t oid) { 
01133         <span class="keywordflow">if</span> (oid &lt; committedIndexSize &amp;&amp; index[0][oid] == index[1][oid]) { 
01134             size_t size = getRow(oid)-&gt;<a class="code" href="classdbRecord.html#dbTablem8">size</a>;
01135             size_t pageNo = oid/dbHandlesPerPage;
01136             monitor-&gt;dirtyPagesMap[pageNo &gt;&gt; 5] |= 1 &lt;&lt; (pageNo &amp; 31);
01137             cloneBitmap(currIndex[oid], size);
01138             allocate(size, oid);
01139         } 
01140         <span class="keywordflow">return</span> (<a class="code" href="classdbRecord.html">dbRecord</a>*)(baseAddr + currIndex[oid]); 
01141     }
01142 
<a name="l01148"></a><a class="code" href="classdbDatabase.html#dbSubSqlb17">01148</a>     byte* get(oid_t oid) { 
01149         <span class="keywordflow">return</span> baseAddr + (currIndex[oid] &amp; ~dbInternalObjectMarker); 
01150     }
01151 
<a name="l01157"></a><a class="code" href="classdbDatabase.html#dbSubSqlb18">01157</a>     byte* put(oid_t oid) { 
01158         <span class="keywordflow">if</span> (oid &lt; committedIndexSize &amp;&amp; index[0][oid] == index[1][oid]) { 
01159             offs_t offs = currIndex[oid];
01160             size_t size = internalObjectSize[offs &amp; dbInternalObjectMarker];
01161             size_t pageNo = oid/dbHandlesPerPage;
01162             monitor-&gt;dirtyPagesMap[pageNo &gt;&gt; 5] |= 1 &lt;&lt; (pageNo &amp; 31);
01163             allocate(size, oid);
01164             cloneBitmap(offs &amp; ~dbInternalObjectMarker, size);
01165         } 
01166         <span class="keywordflow">return</span> baseAddr + (currIndex[oid] &amp; ~dbInternalObjectMarker); 
01167     }
01168     
01182     <span class="keywordtype">bool</span> isPrefixSearch(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
01183                         dbExprNode* expr, dbExprNode* andExpr, 
01184                         <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* &amp;indexedField);
01185 
01199     <span class="keywordtype">bool</span> isIndexApplicable(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
01200                            dbExprNode* expr, dbExprNode* andExpr, 
01201                            <a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* &amp;indexedField);
01202 
01214     <span class="keywordtype">bool</span> isIndexApplicable(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, 
01215                            dbExprNode* expr, dbExprNode* andExpr);
01216 
01229     <span class="keywordtype">bool</span> followInverseReference(dbExprNode* expr, dbExprNode* andExpr, 
01230                                 <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, oid_t iref);
01231 
01239     <span class="keywordtype">bool</span> existsInverseReference(dbExprNode* expr, <span class="keywordtype">int</span> nExistsClauses);
01240 
01250     <span class="keyword">static</span> <span class="keywordtype">void</span> _fastcall execute(dbExprNode* expr, 
01251                                   dbInheritedAttribute&amp; iattr,
01252                                   dbSynthesizedAttribute&amp; sattr);
01253 
01263     <span class="keywordtype">bool</span> evaluate(dbExprNode* expr, oid_t oid, <a class="code" href="classdbTable.html">dbTable</a>* table, <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor);
01264 
01269     <span class="keywordtype">void</span> select(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor);
01270 
01276     <span class="keywordtype">void</span> select(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
01277 
01283     <span class="keywordtype">void</span> traverse(<a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>* cursor, <a class="code" href="classdbQuery.html">dbQuery</a>&amp; query);
01284 
01291     <span class="keywordtype">void</span> update(oid_t oid, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, <span class="keywordtype">void</span> <span class="keyword">const</span>* record);
01292     
01298     <span class="keywordtype">void</span> remove(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t oid);
01299 
01307     offs_t allocate(size_t size, oid_t oid = 0);
01308 
01314     <span class="keywordtype">void</span> deallocate(offs_t pos, size_t size);
01315 
01321     <span class="keywordtype">void</span> extend(offs_t size);
01322 
01328     <span class="keywordtype">void</span> cloneBitmap(offs_t pos, size_t size);
01329 
01336     oid_t allocateId(<span class="keywordtype">int</span> n = 1);
01337 
01344     <span class="keywordtype">void</span> freeId(oid_t oid, <span class="keywordtype">int</span> n = 1);
01345 
01351     <span class="keywordtype">void</span> updateCursors(oid_t oid, <span class="keywordtype">bool</span> removed = <span class="keyword">false</span>);
01352     
01356     <span class="keywordtype">void</span> recovery();
01357 
01366     <span class="keywordtype">bool</span> checkVersion();
01367 
<a name="l01373"></a><a class="code" href="classdbDatabase.html#dbSubSqlb38">01373</a>     oid_t allocateObject(dbInternalObject marker) {
01374         oid_t oid = allocateId();
01375         offs_t pos = allocate(internalObjectSize[marker]) + marker;
01376         currIndex[oid] = pos;
01377         <span class="keywordflow">return</span> oid;
01378     }
01379 
<a name="l01386"></a><a class="code" href="classdbDatabase.html#dbSubSqlb39">01386</a>     oid_t allocateRow(oid_t tableId, size_t size)
01387     {
01388         oid_t oid = allocateId();
01389         allocateRow(tableId, oid, size);
01390         <span class="keywordflow">return</span> oid;
01391     }
01392     
01400     <span class="keywordtype">void</span> allocateRow(oid_t tableId, oid_t oid, size_t size);
01401 
01407     <span class="keywordtype">void</span> freeRow(oid_t tableId, oid_t oid);
01408 
01412     <span class="keywordtype">void</span> freeObject(oid_t oid); 
01413     
01417     <span class="keyword">static</span> <span class="keywordtype">void</span> deleteCompiledQuery(dbExprNode* tree); 
01418 
01425     <span class="keywordtype">bool</span> beginTransaction(dbLockType);
01426 
<a name="l01430"></a><a class="code" href="classdbDatabase.html#dbSubSqlb44">01430</a>     <span class="keywordtype">void</span> endTransaction() { 
01431         endTransaction(threadContext.get());
01432     }
01433     
01438     <span class="keywordtype">void</span> endTransaction(dbDatabaseThreadContext* ctx);
01439 
01440     <span class="keyword">virtual</span> <span class="keywordtype">void</span> waitTransactionAcknowledgement();
01441 
01446     <span class="keywordtype">void</span> initializeMetaTable();
01447     
01455     <span class="keywordtype">bool</span> loadScheme(<span class="keywordtype">bool</span> alter);
01456 
01462     <span class="keywordtype">bool</span> completeDescriptorsInitialization();
01463 
01469     <span class="keywordtype">void</span> reformatTable(oid_t tableId, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
01470 
01478     <span class="keywordtype">bool</span> addIndices(<span class="keywordtype">bool</span> alter, <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
01479 
01485     oid_t addNewTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
01486 
01492     <span class="keywordtype">void</span> updateTableDescriptor(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t tableId);
01493 
01502     <span class="keywordtype">void</span> insertInverseReference(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, 
01503                                 oid_t reverseId, oid_t targetId);
01504 
01510     <span class="keywordtype">void</span> removeInverseReferences(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc, oid_t oid);
01511 
01520     <span class="keywordtype">void</span> removeInverseReference(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd, 
01521                                 oid_t reverseId, oid_t targetId);
01522 
01527     <span class="keywordtype">void</span> deleteTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
01528 
01533     <span class="keywordtype">void</span> dropTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* desc);
01534 
01539     <span class="keywordtype">void</span> createIndex(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
01540 
01545     <span class="keywordtype">void</span> createHashTable(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
01546 
01551     <span class="keywordtype">void</span> dropIndex(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
01552 
01557     <span class="keywordtype">void</span> dropHashTable(<a class="code" href="classdbFieldDescriptor.html">dbFieldDescriptor</a>* fd);
01558 
01564     <span class="keywordtype">void</span> linkTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table, oid_t tableId);
01565 
01570     <span class="keywordtype">void</span> unlinkTable(<a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* table);
01571 
01578     <span class="keywordtype">bool</span> wasReserved(offs_t pos, size_t size);
01579 
01588     <span class="keywordtype">void</span> reserveLocation(dbLocation&amp; location, offs_t pos, size_t size);
01589 
01594     <span class="keywordtype">void</span> commitLocation();
01595 
01601     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* findTable(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
01602     
01609     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* findTableByName(<span class="keywordtype">char</span> <span class="keyword">const</span>* name);
01610 
<a name="l01615"></a><a class="code" href="classdbDatabase.html#dbSubSqlb70">01615</a>     <a class="code" href="classdbTableDescriptor.html">dbTableDescriptor</a>* getTables() { 
01616         <span class="keywordflow">return</span> tables;
01617     }
01618 
01622     <span class="keywordtype">void</span> setDirty();
01623 
01629     <span class="keywordtype">bool</span> isFree(offs_t pos, <span class="keywordtype">int</span> objBitSize);
01630 
01636     <span class="keywordtype">void</span> markAsAllocated(offs_t pos, <span class="keywordtype">int</span> objBitSize);
01637 
01638 };
01639 
01640 
01641 <span class="preprocessor">#ifdef REPLICATION_SUPPORT</span>
01642 <span class="preprocessor"></span>
01643 <span class="preprocessor">#include "sockio.h"</span>
01644 
01645 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbConnection { 
01646  <span class="keyword">public</span>:
01647     socket_t*    reqSock;
01648     socket_t*    respSock;
01649     dbLocalEvent statusEvent;
01650     dbLocalEvent readyEvent;
01651     dbLocalEvent useEvent;
01652     dbLocalEvent committedEvent;
01653     dbMutex      writeCS;
01654     <span class="keywordtype">int</span>          useCount;
01655     <span class="keywordtype">int</span>          waitUseEventFlag;
01656     <span class="keywordtype">int</span>          waitStatusEventFlag;
01657     <span class="keywordtype">int</span>          status;
01658     <span class="keywordtype">int</span>          updateCounter;
01659     <span class="keywordtype">int</span>          nRecoveredPages;
01660 
01661     dbConnection() { 
01662         readyEvent.open();
01663         useEvent.open();
01664         statusEvent.open();
01665         committedEvent.open();
01666         useCount = 0;
01667         waitUseEventFlag = 0;
01668         waitStatusEventFlag = 0;
01669         status = 0;
01670         reqSock = respSock = NULL;
01671         nRecoveredPages = 0;
01672     }
01673     ~dbConnection() { 
01674         readyEvent.close();
01675         useEvent.close();
01676         statusEvent.close();
01677         committedEvent.close();
01678         <span class="keyword">delete</span> reqSock;
01679         <span class="keyword">delete</span> respSock;
01680     }
01681 }; 
01682 
01683 <span class="keyword">class </span>FASTDB_DLL_ENTRY dbReplicatedDatabase : <span class="keyword">public</span> dbDatabase {
01684     <span class="keyword">friend</span> <span class="keyword">class </span>dbFile;
01685   <span class="keyword">protected</span>:
01686     <span class="keywordtype">char</span>**        serverURL;
01687     <span class="keywordtype">int</span>           nServers;
01688     <span class="keywordtype">int</span>           id;
01689     dbConnection* con;
01690 
01691     <span class="keyword">enum</span> NodeStatus { 
01692         ST_OFFLINE,  <span class="comment">// node is not available </span>
01693         ST_ONLINE,   <span class="comment">// node is available </span>
01694         ST_ACTIVE,   <span class="comment">// primary node is running, replicating changes</span>
01695         ST_STANDBY,  <span class="comment">// standby node receives changes from primary node</span>
01696         ST_RECOVERED <span class="comment">// node is recovered after the fault</span>
01697     };
01698     
01699     dbLocalEvent  startEvent;
01700     dbLocalEvent  recoveredEvent;
01701     dbMutex       startCS;
01702     dbMutex       commitCS;
01703     fd_set        inputSD;
01704     <span class="keywordtype">int</span>           nInputSD;
01705 
01706     <span class="keywordtype">int</span>           activeNodeId;
01707     <span class="keywordtype">int</span>           masterNodeId;
01708     <span class="keywordtype">bool</span>          onlineRecovery;
01709     <span class="keywordtype">bool</span>          handshake; 
01710     dbMutex       sockCS;
01711     socket_t*     acceptSock;
01712     dbThread      readerThread;
01713 
01714     <span class="keywordtype">int</span> pollInterval;
01715     <span class="keywordtype">int</span> waitReadyTimeout;
01716     <span class="keywordtype">int</span> waitStatusTimeout;
01717     <span class="keywordtype">int</span> recoveryConnectionAttempts;
01718     <span class="keywordtype">int</span> startupConnectionAttempts;
01719     <span class="keywordtype">int</span> replicationWriteTimeout;
01720     <span class="keywordtype">int</span> maxAsyncRecoveryIterations;
01721 
01722     <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc startReader(<span class="keywordtype">void</span>* arg);
01723 
01724     <span class="keywordtype">void</span> waitTransactionAcknowledgement();
01725 
01726     <span class="keywordtype">void</span> reader();
01727     <span class="keyword">virtual</span> <span class="keywordtype">void</span> close0();
01728     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isReplicated();
01729 
01730   <span class="keyword">public</span>:
01731     <span class="keywordtype">void</span> deleteConnection(<span class="keywordtype">int</span> nodeId);
01732     <span class="keywordtype">void</span> lockConnection(<span class="keywordtype">int</span> nodeId);
01733     <span class="keywordtype">void</span> unlockConnection(<span class="keywordtype">int</span> nodeId);
01734     <span class="keywordtype">void</span> changeActiveNode();
01735     <span class="keywordtype">void</span> addConnection(<span class="keywordtype">int</span> nodeId, socket_t* s);
01736     <span class="keywordtype">bool</span> writeReq(<span class="keywordtype">int</span> nodeId, ReplicationRequest <span class="keyword">const</span>&amp; hdr, 
01737                   <span class="keywordtype">void</span>* body = NULL, size_t bodySize = 0);
01738     <span class="keywordtype">bool</span> writeResp(<span class="keywordtype">int</span> nodeId, ReplicationRequest <span class="keyword">const</span>&amp; hdr);
01739 
01740     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#dbSubSqla6">open</a>(<span class="keywordtype">char</span> <span class="keyword">const</span>* databaseName, <span class="keywordtype">char</span> <span class="keyword">const</span>* fileName,
01741               <span class="keywordtype">int</span> id, <span class="keywordtype">char</span>* servers[], <span class="keywordtype">int</span> nServers);
01742     <span class="keywordtype">bool</span> <a class="code" href="classdbDatabase.html#dbSubSqla6">open</a>(OpenParameters&amp; params);
01743 
01744     <span class="keywordtype">int</span> getNumberOfOnlineNodes();
01745 
01746     dbReplicatedDatabase(dbAccessType type = dbAllAccess,
01747                          size_t dbInitSize = dbDefaultInitDatabaseSize,
01748                          size_t dbExtensionQuantum = dbDefaultExtensionQuantum,
01749                          size_t dbInitIndexSize = dbDefaultInitIndexSize,
01750                          <span class="keywordtype">int</span> nThreads = 1);
01751 };
01752 <span class="preprocessor">#endif</span>
01753 <span class="preprocessor"></span>
01754 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
01755 <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> insert(T <span class="keyword">const</span>&amp; record) { 
01756     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
01757     T::dbDescriptor.getDatabase()-&gt;insertRecord(&amp;T::dbDescriptor, &amp;ref, &amp;record);
01758     <span class="keywordflow">return</span> ref;
01759 }
01760 
01761 <span class="preprocessor">#ifdef NO_MEMBER_TEMPLATES</span>
01762 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
01763 <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> insert(dbDatabase&amp; db, T <span class="keyword">const</span>&amp; record) {
01764     <a class="code" href="classdbReference.html">dbReference&lt;T&gt;</a> ref;
01765     db.<a class="code" href="classdbDatabase.html#dbSubSqla33">insertRecord</a>(db.<a class="code" href="classdbDatabase.html#dbSubSqla41">lookupTable</a>(&amp;T::dbDescriptor), &amp;ref, &amp;record);
01766     <span class="keywordflow">return</span> ref;
01767 }
01768 <span class="preprocessor">#endif</span>
01769 <span class="preprocessor"></span>
<a name="l01773"></a><a class="code" href="classdbSearchContext.html">01773</a> <span class="keyword">class </span><a class="code" href="classdbSearchContext.html">dbSearchContext</a> { 
01774   <span class="keyword">public</span>:
01775     dbDatabase*     db;
01776     dbExprNode*     condition;
01777     <a class="code" href="classdbAnyCursor.html">dbAnyCursor</a>*    cursor;
01778     <span class="keywordtype">char</span>*           firstKey;
01779     <span class="keywordtype">int</span>             firstKeyInclusion;
01780     <span class="keywordtype">char</span>*           lastKey;
01781     <span class="keywordtype">int</span>             lastKeyInclusion;
01782     <span class="keywordtype">int</span>             type;
01783     <span class="keywordtype">int</span>             sizeofType;
01784     <span class="keywordtype">int</span>             prefixLength;
01785     dbUDTComparator comparator;
01786     <span class="keywordtype">int</span>             offs;
01787     <span class="keywordtype">int</span>             probes;
01788 };
01789 
01790 
01791 END_FASTDB_NAMESPACE
01792 
01793 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Thu Feb 14 12:42:30 2008 for FastDB by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
